% 
\pdfcompresslevel0
 
%\newcount\crashcounter
%\appendtoks
%\ifnum\crashcounter=85 \stoptext \fi
%\global\advance\crashcounter\plusone
%[\the\crashcounter]
% \ctxlua{%
%    texio.write_nl("PAR NUMBER: \the\crashcounter")
%    for _,v in pairs(statistics.list()) do texio.write_nl (_ .. "=" .. v) end
%}\to\everypar

\environment luatexref-env

\setupalign[flushleft]

\catcode`\_=12

\def\hex{"}

\def\todo#1{{\bf\red <TODO: #1>}}

\starttext
\TitlePage{Snapshot 2007-03-07}

%\appendtoks \newlinechar13 \to\everyMPgraphic

\title{Contents}

\placecontent[criterium=text,level=subsection]

\chapter{Introduction}


\startframedtext[framecolor=red,width=\hsize]
\red 
This book will eventually become the reference manual of \LUATEX. At
the moment, it simply reports the behavior of the executable
matching the snapshot date in the title page.

\blank

Features may come and go. The current version of \LUATEX\ is not meant
for production and users cannot depend on functionality staying the
same.

\blank

Nothing in the API is considered stable just yet. This manual
therefore simply reflects the current state of the executable. {\bs 
Absolutely nothing\/} on the following pages is set in stone. When the
need arises, anything can (and will) be changed without prior notice.

\blank

\bf If you are unhappy with this situation, wait for the public betas.
\stopframedtext

\blank[2*line]

\LUATEX\ consists of a number of interrelated but (still) distinguishable
 parts:
\startitemize
\item \PDFTEX\ version 1.40.3
\item \ALEPH\ RC4 (from the \TEXLIVE\ repository)
\item Functionality of \ETEX\ 2.2
\item Lua 5.1.1
\item Dedicated lua libraries
\item Various \TeX\ extensions
\item The (OpenType) Font Parser from FontForge 2006.12.20
\item Compiled source code to glue it all together
\stopitemize

\LUATEX\ has two separate identities:

\startitemize[n]
\item When \type{\pdfoutput} is set to one, \LUATEX\ behaves like \PDFTEX,
with the addition of OTP processing and Aleph directionality commands.  

\item When \type{\pdfoutput} is zero, \LUATEX\ behaves like \ALEPH\ with the
addition of the micro-typography features. The \PDFTEX\ commands that are not
specific to the PDF output format should work.
\stopitemize

In either mode, neither I/O translation processes, nor tcx files, nor
enctex can be used. All these encoding-related functions are
superseded by a \LUA-based solution (\type{reader} callbacks).

\chapter{Basic \TEX\ enhancements}

\section{Unicode support}

Text input and output is now considered to be Unicode text, so
characters can use the full range of Unicode ($2^{20}+2^{16} =
\hbox{\hex10FFFF} = 1114111$). 

For now, it only makes sense to use values above the base plane (\hex
FFFF) for \type{\mathcode} and \type{\catcode} assignments, since the
hyphenation patterns are still limited to at the most 16-bit values,
so the other commands will not know what to do with those high values.

Many primitives are affected by this. For instance,
\type{\char} now accepts values between 0 and 1114111. This should not
be a problem for well-behaved input files, but it could create
incompatibilities for input that would have generated an error when
processed by older \TEX-based engines.

\starttable[|l|l|l|l|]
\NC Primitive           \NC Bits    \NC Hex    \NC Range                 \NC \FR
\NC \type{\char}        \NC 21      \NC \hex10FFFF \NC ($2^{20}+2^{16}$)      \NC\NR
\NC \type{\chardef}     \NC 21=21   \NC \hex10FFFF=\hex10FFFF   \NC ($2^{20}+2^{16}$) = ($2^{20}+2^{16}$)     \NC\NR
\NC \type{\lccode}      \NC 21=21   \NC \hex10FFFF=\hex10FFFF   \NC ($2^{20}+2^{16}$) = ($2^{20}+2^{16}$)\NC\NR
\NC \type{\uccode}      \NC 21=21   \NC \hex10FFFF=\hex10FFFF   \NC ($2^{20}+2^{16}$) = ($2^{20}+2^{16}$)\NC\NR
\NC \type{\sfcode}      \NC 21=15   \NC \hex10FFFF=\hex7FFF   \NC ($2^{20}+2^{16}$) = ($2^{15}$)\NC\NR
\NC \type{\catcode}     \NC 21=4    \NC \hex10FFFF=\hex F    \NC ($2^{20}+2^{16}$) = ($2^4$)\NC\NR
\NC \type{\mathchardef} \NC 21=15   \NC \hex10FFFF=\hex8000   \NC ($2^{20}+2^{16}$) = ($2^{3}*2^{8}*2^{4}$) \NC\NR
\NC \type{\mathcode}    \NC 21=15   \NC \hex10FFFF=\hex8000   \NC ($2^{20}+2^{16}$) = ($2^{3}*2^{8}*2^{4}$) \NC\NR
\NC \type{\delcode}     \NC 21=27   \NC \hex10FFFF=\hex7FFFFFF   \NC ($2^{20}+2^{16}$) = ($2^{3}*2^{4}*2^{8}*2^{4}*2^{8}$)\NC\NR 
\stoptable

As far as the core engine is concerned, all input and output to text
files is UTF-8 encoded. Input files can be preprocessed using the
\callback{reader} callback. This will be explained in a later chapter.

Output in byte-sized chunks can be achieved by using characters in the
private use block that starts at index 1.113.856 (\hex10FF00). When
the times comes to print a character $c>=1.113.856$, \LUATEX\ will
actually print the single byte corresponding to $c-1.113.856$.

Output to the terminal uses \type{^^} notation for the lower control
range ($c<32$), with the exception of \type{^^I}, \type{^^J} and
\type{^^M}.  These are considered `safe' and therefore printed as-is.

Normalization of the Unicode input can be handled by a macro package
during callback processing (will be explained below).

\section{Wide math characters}

Text is now extended up to the full Unicode range, but math mode deals
mostly with glyphs in fonts directly, and fonts tend to be 16-bit at
maximum.

Therefore, the math primitives from \ALEPH\ are kept mostly as-is,
except for the ones that convert from input to math commands. The
extended commands (with the `\type{o}' prefix) accept 16-bit glyph
indices in one of 256 possible families. The traditional \TEX\
primitives are unchanged, their arguments are upscaled internally.

\starttable[|l|l|l|l|]
\NC Primitive           \NC Bits    \NC Hex    \NC Range                 \NC \FR
\NC \type{\mathchar}    \NC 15      \NC \hex7FFF   \NC ($2^{3}*2^{8}*2^{4}$)  \NC\NR
\NC \type{\delimiter}   \NC 27      \NC \hex7FFFFFF      \NC ($2^{3}*2^{4}*2^{8}*2^{4}*2^{8}$)\NC\NR
\NC \type{\omathchar}   \NC 27      \NC \hex7FFFFFF\NC ($2^{3}*2^{16}*2^{8}$)  \NC\NR
\NC \type{\odelimiter}  \NC 27+24   \NC \hex7FFFFFF+\hex FFFFFF   \NC ($2^{3}*2^{8}*2^{16}$)+($2^{8}*2^{16}$)\NC\NR
\NC \type{\omathchardef}\NC 21=27   \NC \hex10FFFF=\hex8000000   \NC ($2^{20}+2^{16}$) = ($2^{3}*2^{16}*2^{8}$)\NC\NR
\NC \type{\omathcode}   \NC 21=27   \NC \hex10FFFF=\hex8000000   \NC ($2^{20}+2^{16}$) = ($2^{3}*2^{16}*2^{8}$) \NC\NR
\NC \type{\odelcode}    \NC 21=27+24\NC \hex10FFFF=\hex7FFFFFF+ \NC($2^{20}+2^{16}$) = ($2^{3}*2^{8}*2^{16}$)+ \NC\NR
\NC                     \NC         \NC \hphantom{\hex10FFFF= }\hex FFFFFF\NC \hphantom{($2^{20}+2^{16}$) = } ($2^{8}*2^{16}$)\NC\LR
\stoptable

\section{Extended register tables}

All registers can be \type{<16-bit number>}, as in \ALEPH. The
affected commands are:

\startcolumns
\starttyping
\count
\dimen
\skip
\muskip
\marks
\toks
\countdef
\dimendef
\skipdef
\muskipdef
\toksdef
\box
\unhbox
\unvbox
\copy
\unhcopy
\unvcopy
\wd
\ht
\dp
\setbox
\vsplit
\stoptyping
\stopcolumns

\section{Lua related primitives}

In order to merge lua code with \TEX\ input, a few new primitives are
needed. \LUATEX\ has support for 65536 separate lua interpreter
states. States are automatically created based on the integer argument
to the primitives \primitive{directlua} and \primitive{latelua}.

\subsection{\primitive{directlua}}

The primitive \primitive{directlua} is used to execute lua code.
The syntax is
\startsyntax
  \directlua <16-bit number> <general text>
\stopsyntax

The \syntax{<general text>} is fed into the lua interpreter state
indicated by the \syntax{<16-bit number>}. If the state does not exist
yet, then it will be initialized automatically.

This command is expandable. 

\subsection{\primitive{latelua}}

\primitive{latelua} stores lua code in a whatsit that will be processed 
inside the output routine. It's intended use is is very similar to
\type{\pdfliteral}.

Within the lua code, you should use \type{pdf.print} to print stuff
directly to the pdffile..

\startsyntax
  \latelua <16-bit number> <general text>
\stopsyntax

\subsection{\primitive{luaescapestring}}

This primitive converts a \TEX\ token string so that it can be safely
used as the contents of a \LUA\ string: embedded backslashes, double
quotes and single quotes are escaped by prepending an extra token
consisting of a backslash with catcode 12.
\startsyntax
  \luaescapestring <general text>
\stopsyntax


\subsection{\primitive{luaclose}} 

This primitive allows you to close a lua state, freeing all of its
used memory.

\startsyntax
  \luaclose <16-bit number>
\stopsyntax

You cannot close lua state zero (0), any attempt to do so will be
silently ignored.

States are only closed automatically when a fatal (out of memory)
error occurs, but at that point \LUATEX\ will exit anyway.

States are not closed immediately, but only when the output routine
comes into play next (because there may be pending \type{\latelua}
calls)

\section{New \ETEX\ primitives}

\subsection{\primitive{clearmarks}}

This primitive clears a marks class completely, resetting all three
connected mark texts to empty.
\startsyntax
      \clearmarks <16-bit number>
\stopsyntax

\subsection{\primitive{formatname}}

\primitive{formatname}'s syntax is identical to \type{\jobname}. 

In initex, the expansion is empty. Otherwise, the expansion is the
value that \type{\jobname} had during the initex run that dumped the
currently loaded format.

\subsection{\primitive{scantextokens}}

The syntax of \primitive{scantextokens} is identical to \type{\scantokens}. 

This is a slightly adapted version of \ETEX's \type{\scantokens}. The 
differences are:

\startitemize
\item The last (and usually only) line does not have a
      \type{\endlinechar} appended
\item \type{\scantextokens} never raises an EOF error,
      and it does not execute \type{\everyeof} tokens.
\item The `while end of file' tests are not executed, allowing
      the expansion to end on a different grouping level or while a
      conditional is still incomplete
\stopitemize


\subsection{Catcode tables}

Catcode tables are a new feature that allows you to switch to a
predefined catcode regime in a single statement. You can have a
practically unlimited number of different tables (at this moment up to
268,435,456. The limit depends on an array allocation).

The subsystem is backward compatible: if you never use the following
commands, your document will not notice any difference in behavior
compared to traditional \TEX.

The contents of each catcode table is independent of any other
catcode tables, and their contents is stored and retrieved from the
format file. 

\subsubsection{\primitive{catcodetable}}
\startsyntax
  \catcodetable <28-bit number>
\stopsyntax

The \primitive{catcodetable} switches to a different catcode table.
Such a table has to be previously created using one of the two
primitives below, or it has to be zero (table zero is initialized by
initex)

\subsubsection{\primitive{initcatcodetable}}
\startsyntax
  \initcatcodetable <28-bit number>
\stopsyntax

The \primitive{initcatcodetable} creates a new table with catcodes
identical to those defined by initex:

\starttable[|l|l|l|]
\NC \type{^^M}~(<return>) \NC \type{car_ret}     \NC5 \NC\NR
\NC \type{ }~(space)      \NC \type{spacer}      \NC10\NC\NR
\NC \type{\\}             \NC \type{escape}      \NC0 \NC\NR
\NC \type{%}              \NC \type{comment}     \NC14\NC\NR
\NC \type{^^?}~(<delete>) \NC \type{invalid_char}\NC15\NC\NR
\NC \type{^^@}~(<null>)   \NC \type{ignore}      \NC9 \NC\NR
\NC \type{a}--\type{z}    \NC \type{letter}      \NC11\NC\NR
\NC \type{A}--\type{Z}    \NC \type{letter}      \NC11\NC\NR
\NC everything else       \NC \type{other}       \NC12\NC\NR
\stoptable

The new catcode table is allocated globally: it will not go away after
the current group has ended. If the supplied number is the currently
active table, an error is raised.

\subsubsection{\primitive{savecatcodetable}}
\startsyntax
  \savecatcodetable <28-bit number>
\stopsyntax

\primitive{savecatcodetable} copies the current set of catcodes to a
new table with the requested number. The definitions in this new table
are all treated as if they were made in the outermost level.

The new table is allocated globally: it will not go away after the
current group has ended. If the supplied number is the currently
active table, an error is raised.

\subsection{Font syntax}

LuaTeX will accept a braced argument as a font name:
\starttyping
\font\myfont = {cmr10}
\stoptyping
This allows for embedded spaces, without the need for double quotes.
Macro expansion takes place in the argument. 

\chapter {Lua general}

\section{Initialization}

\subsection{Luatex as a lua interpreter}

In a number of cases, luatex behaves like it is a lua interpreter only.

\startitemize
\item If a \type{--luaonly} option is given
\item If the executable is named \type{luatexlua}
\item if the non-option (file) on the command-line has the extension 
	\type{lua} or \type{luc}.
\stopitemize

On this mode, it will set Lua's \type{arg[0]} to the found script
name, pushing preceding options in negative values and the rest of the
commandline in the positive values, just like the `\type{lua}'
interpreter.

\LUATEX\ will exit immediately after executing the specified Lua
script and is, in effect, a somehwat bulky standalone lua interpreter.

\subsection{Other command-line processing}

Whenever the \LUATEX\ executable starts, it looks for a \type{--lua}
command||line option. If such an option is present, it will enter an
alternative mode of command||line parsing.

In this mode, it will only interpret a very small subset of the
command||line directly:
\starttable[|l|l|]
\NC --luaonly    \NC execute a lua script, then exit      \NC \AR
\NC --lua=s      \NC load and execute a lua init script   \NC \AR
\NC --safer      \NC disable easily exploitable lua commands\NC \AR
\NC --help       \NC display help and exit                \NC \AR
\NC --version    \NC display version and exit             \NC \AR
\stoptable

If a requested lua script can not be found using the actual name given
on the command||line, a second attempt is made by prepending the value
of the environment variable \type{LUATEXDIR}, if that variable is
defined.

Then the script is loaded and executed. It will find the entire
commandline in the table \type{arg}, beginning with \type{arg[0]},
that is the name of the executable. 

\LUATEX\ will fetch some of the other commandline options from 
the \type{texconfig} table at the end of script execution (see the
description of the \type{texconfig} table later on in this document).

Commandline processing happens very early on. So early, in fact, that
none of \TEX's initializations have taken place yet. For that reason,
the \type{tex} and \type{pdf} tables are off-limits during the
execution of the startup file (they are nilled). Special care is taken
that \type{texio.write} and \type{texio.write_nl} function properly,
so that you can at least report your actions to the log file when (and
if) it eventually becomes opened (note that \TEX\ does not even know
it's \type{\jobname} yet at this point).

The file is loaded into Lua state 0, and everything you do will remain
visible during the rest of the run, with the exception of the
\type{tex} and \type{pdf} tables: those will be restored to their
normal meaning right after the execution of the script. 

We recommend you use the startup file only for your own
\TEX-independant initializations (if you need any), to parse the
command||line, set values in the \type{texconfig} table, and
register the callbacks you need.


You can use the \type{--safer} switch to disable some commands that
can easily be abused by a malicious document. At the moment, this
switch \type{nil}s the following functions:

\starttable[|l|l|]
\NC \type{os.execute()}\NC\AR
\NC \type{os.exec()}\NC\AR
\NC \type{os.setenv()}\NC\AR
\NC \type{os.rename()}\NC\AR
\NC \type{os.remove()}\NC\AR
\NC \type{io.popen()}\NC\AR
\NC \type{io.output()}\NC\AR
\NC \type{io.tmpfile()}\NC\AR
\NC \type{lfs.rmdir()}\NC\AR
\NC \type{lfs.mkdir()}\NC\AR
\NC \type{lfs.chdir()}\NC\AR
\NC \type{lfs.lock()}\NC\AR
\NC \type{lfs.touch()}\NC\AR
\stoptable

And it makes \type{io.open()} fail on files that are opened for
anything besides reading.

Unless the \type{texconfig} table tells it not to start kpathsea at
all (set \type{texconfig.kpse_init} to \type{false} for that), it also
acts on three other command||line options:

\starttable[|l|l|]
\NC --fmt=s      \NC set the format name                  \NC \AR
\NC --progname=s \NC set the progname (only for kpathsea) \NC \AR
\NC --ini        \NC enable initex mode                   \NC \AR
\stoptable

In order to initialize the built-in kpathsea library properly,
\LUATEX\ needs to know the correct `progname' to use, and for that it 
needs to check \type{-progname} (and \type{-ini} and \type{-fmt}, if
\type{-progname} is missing).

If there is no \type{--lua} option, the commandline is interpreted
in a similar fashion as in traditional \PDFTEX\ and \ALEPH.

\section{Lua changes}

Five modules that are normally external are statically linked in with
\LUATEX: \type{slnunicode}, \type{luazip}, \type{luafilesystem}, 
\type{lpeg} (version 0.4), and \type{md5}.

The \type{read("*line")} function from the io library has been
adjusted so that it is line-ending neutral: any of \type{LF}, \type
{CR} or type{CR+LF} are accepted.

The \type{tostring()} printer for numbers has been changed so that it
returns `0' instead of something like `2e-5' (which confused \TEX\
enormously) when the value is so small that \TEX\ cannot distinguish
it from zero.

The (currently three) known bugs in Lua 5.1.1 have been patched.

Dynamic loading of \type{.so} and \type{.dll} files is disabled on
all platforms.

\type{luafilesystem} has been extended with two extra boolean functions
(\type{isdir(filename)} and \type{isfile(filename)}) and one extra
string field in the attributes table (\type{permissions}).

The \type{string} library has six extra iterators that return strings
piecemeal: "utfvalues" (returns an integer value in the unicode
range), "utfcharacters" (returns a string with a single UTF-8 token in
it), "characters" (a string of length one), "characterpairs" (two
strings of length one), "bytes" (a single byte value), and "bytepairs"
(two byte values).  The "bytepairs" will produce nil instead of a
number as its second return value if the string length was odd.
"characterpairs" will produce an empty second string in that case.

The \type{os} library has a few extra functions and variables:

\startitemize
\item \type{os.exec('command')} is a non-returning version of \type{os.execute}. 
  The advantage of this command is that it cleans out the current
  process before starting the new one, making it especially useful for
  use in \type{luatexlua}. 

\item \type{os.setenv('key','value')}
  This sets a variable in the environment. Passing `nil' instead of a
  value string will remove the variable.

\item \type{os.environ}
  This is a read-only hash table containing all of the variables and
  values in the process environment.

\stopitemize


\chapter{Lua Libraries}

The interfacing between \TEX\ and \LUA\ is facilitated by a set of
\LUA\ modules.

\section{The \lualib{tex} library}

The \lualib{tex} table contains a large list of virtual internal \TEX\
parameters that are partially writable.

The designation `virtual' means that these items are not properly
defined in Lua, but are only frontends that are handled by a metatable
that operates on the actual \TEX\ values. As a result, most of the lua
table operators (like \type{pairs} and \type{#}) do not work on such
items.


At the moment, it is possible to access almost every parameter
that has these characteristics:
\startitemize
\item You can use it after \type{\the} 
\item It is a single token. 
\stopitemize
This excludes parameters that need extra arguments, like
\type{\the\scriptfont}.

The subset comprising simple integer and dimension registers are
writable as well as readable (stuff like \type{\tracingcommands} and
\type{\parindent}).

\subsection{Integer parameters}

The integer parameters accept and return lua numbers.

Read-write:

\startcolumns
\starttyping
tex.adjdemerits
tex.binoppenalty
tex.brokenpenalty
tex.catcodetable
tex.clubpenalty
tex.day
tex.defaulthyphenchar
tex.defaultskewchar
tex.delimiterfactor
tex.displaywidowpenalty
tex.doublehyphendemerits
tex.endlinechar
tex.errorcontextlines
tex.escapechar
tex.exhyphenpenalty
tex.fam
tex.finalhyphendemerits
tex.floatingpenalty
tex.globaldefs
tex.hangafter
tex.hbadness
tex.holdinginserts
tex.hyphenpenalty
tex.interlinepenalty
tex.language
tex.lastlinefit
tex.lefthyphenmin
tex.linepenalty
tex.localbrokenpenalty
tex.localinterlinepenalty
tex.looseness
tex.mag
tex.maxdeadcycles
tex.month
tex.newlinechar
tex.outputpenalty
tex.pausing
tex.pdfadjustinterwordglue
tex.pdfadjustspacing
tex.pdfappendkern
tex.pdfcompresslevel
tex.pdfdecimaldigits
tex.pdfforcepagebox
tex.pdfgamma
tex.pdfgentounicode
tex.pdfimageapplygamma
tex.pdfimagegamma
tex.pdfimagehicolor
tex.pdfimageresolution
tex.pdfinclusionerrorlevel
tex.pdfminorversion
tex.pdfmovechars
tex.pdfobjcompresslevel
tex.pdfoptionalwaysusepdfpagebox
tex.pdfoptionpdfinclusionerrorlevel
tex.pdfoptionpdfminorversion
tex.pdfoutput
tex.pdfpagebox
tex.pdfpkresolution
tex.pdfprependkern
tex.pdfprotrudechars
tex.pdftracingfonts
tex.pdfuniqueresname
tex.postdisplaypenalty
tex.predisplaydirection
tex.predisplaypenalty
tex.pretolerance
tex.relpenalty
tex.righthyphenmin
tex.savinghyphcodes
tex.savingvdiscards
tex.showboxbreadth
tex.showboxdepth
tex.time
tex.tolerance
tex.tracingassigns
tex.tracingcommands
tex.tracinggroups
tex.tracingifs
tex.tracinglostchars
tex.tracingmacros
tex.tracingnesting
tex.tracingonline
tex.tracingoutput
tex.tracingpages
tex.tracingparagraphs
tex.tracingrestores
tex.tracingscantokens
tex.tracingstats
tex.uchyph
tex.vbadness
tex.widowpenalty
tex.year
\stoptyping
\stopcolumns

Read-only:

\startcolumns
\starttyping
tex.deadcycles
tex.insertpenalties
tex.parshape
tex.prevgraf
tex.spacefactor
\stoptyping
\stopcolumns


\subsection{Dimension parameters}

The dimension parameters accept lua numbers (signifying scaled points)
or strings (with included dimension). The result is always a string.

Read-write:

\startcolumns
\starttyping
tex.boxmaxdepth
tex.delimitershortfall
tex.displayindent
tex.displaywidth
tex.emergencystretch
tex.hangindent
tex.hfuzz
tex.hoffset
tex.hsize
tex.lineskiplimit
tex.mathsurround
tex.maxdepth
tex.nulldelimiterspace
tex.overfullrule
tex.pagebottomoffset
tex.pageheight
tex.pagerightoffset
tex.pagewidth
tex.parindent
tex.pdfdestmargin
tex.pdfeachlinedepth
tex.pdfeachlineheight
tex.pdffirstlineheight
tex.pdfhorigin
tex.pdflastlinedepth
tex.pdflinkmargin
tex.pdfpageheight
tex.pdfpagewidth
tex.pdfpxdimen
tex.pdfthreadmargin
tex.pdfvorigin
tex.predisplaysize
tex.scriptspace
tex.splitmaxdepth
tex.vfuzz
tex.voffset
tex.vsize
\stoptyping
\stopcolumns

Read-only:

\startcolumns
\starttyping
tex.pagedepth
tex.pagefilllstretch
tex.pagefillstretch
tex.pagefilstretch
tex.pagegoal
tex.pageshrink
tex.pagestretch
tex.pagetotal
tex.prevdepth
\stoptyping
\stopcolumns

\subsection{Direction parameters}

All direction parameters are read-only and return a lua string

\startcolumns
\starttyping
tex.bodydir
tex.mathdir
tex.pagedir
tex.pardir
tex.textdir
\stoptyping
\stopcolumns

\subsection{Glue parameters} 

All glue parameters are read-only and return a lua string

\startcolumns
\starttyping
tex.abovedisplayshortskip
tex.abovedisplayskip
tex.baselineskip
tex.belowdisplayshortskip
tex.belowdisplayskip
tex.leftskip
tex.lineskip
tex.parfillskip
tex.parskip
tex.rightskip
tex.spaceskip
tex.splittopskip
tex.tabskip
tex.topskip
tex.xspaceskip
\stoptyping
\stopcolumns

\subsection{Muglue parameters}

All muglue parameters are read-only and return a lua string

\starttyping
tex.medmuskip
tex.thickmuskip
tex.thinmuskip
\stoptyping

\subsection{Tokenlist parameters}

All tokenlist parameters are read-only and return a lua string

\startcolumns
\starttyping
tex.errhelp
tex.everycr
tex.everydisplay
tex.everyeof
tex.everyhbox
tex.everyjob
tex.everymath
tex.everypar
tex.everyvbox
tex.output
tex.pdfpageattr
tex.pdfpageresources
tex.pdfpagesattr
tex.pdfpkmode
\stoptyping
\stopcolumns

\subsection{Convert commands}

The supported commands at this moment are:

\startcolumns
\starttyping
tex.AlephVersion
tex.Alephrevision
tex.OmegaVersion
tex.Omegarevision
tex.eTeXVersion
tex.eTeXrevision
tex.formatname
tex.jobname
tex.pdfnormaldeviate
tex.pdftexbanner
tex.pdftexrevision
\stoptyping
\stopcolumns

All `convert' commands are read-only and return a lua string

This list looks haphazard, but it really is not. These are all the
cases of the `convert' internal command that do not require an
argument. 

\subsection{Count, dimension and token registers}

\TeX's counters (\type{\count}), dimensions (\type{\dimen}) and token
(\type{\toks}) registers can be accessed and written to using three
virtual sub-tables of the \type{tex} table:

\starttyping
    tex.count
    tex.dimen
    tex.toks
\stoptyping

It is possible to use the names of relevant \type{\countdef},
\type{\dimendef}, or \type{\toksdef} control sequences as indices 
to these tables:

\starttyping
    tex.count.scratchcounter = 0
    enormous = tex.dimen["maxdimen"]
\stoptyping

In this case, luatex looks up the value for you on the fly. You have
to use a valid \type{\countdef} (or \type{\dimendef}, or
\type{\toksdef}), anything else will generate an error 
(the goal is to eventually also allow \type{<chardef tokens>} and
even macros that expand into a number)

The count registers accept and return lua numbers.

The dimension registers accept lua numbers (in scaled points) or
strings (with an included absolute dimension. "em" and "ex" and "px"
are forbidden). The result is always a number in scaled points.

The token registers accept and return lua strings. Lua strings are
converted to token lists using \type{\the\toks} style expansion.

As an alternative to array addressing, there are also accessor
functions defined:

\startfunctioncall
  tex.setdimen(number n, string s)
  tex.setdimen(string s, string s)
  tex.setdimen(number n, number n)
  tex.setdimen(string s, number n)
  number n = tex.getdimen(number n)
  number n = tex.getdimen(string s)

  tex.setcount(number n, number n)
  tex.setcount(string s, number n)
  number n = tex.getcount(number n)
  number n = tex.getcount(string s)

  tex.settoks (number n, string s)
  tex.settoks (string s, string s)
  string s = tex.gettoks (number n)
  string s = tex.gettoks (string s)
\stopfunctioncall

\subsection{Box register size information}

The current dimensions of \type{\box} registers can be read and
altered using three other virtual sub-tables :

\starttyping
    tex.wd
    tex.ht
    tex.dp
\stoptyping

These are indexed strictly by number.

The box size registers accept lua numbers (in scaled points)
or strings (with included dimension). The result is always a number
in scaled points.


As an alternative to array addressing, there are also accessor
functions defined:

\startfunctioncall
  tex.setboxwd(number n, string s)
  tex.setboxwd(number n, number n)
  number n = tex.getboxwd(number n)

  tex.setboxht(number n, string s)
  tex.setboxht(number n, number n)
  number n = tex.getboxht(number n)

  tex.setboxdp(number n, string s)
  tex.setboxdp(number n, number n)
  number n = tex.getboxdp(number n)
\stopfunctioncall


\subsection{Print functions}

The \type{tex} table also contains the three print functions that
are the major interface from lua scripting to \TEX. 

The arguments to these three functions are all stored in an in-memory
virtual file that is fed to the \TEX\ scanner as the result of the
expansion of \type{\directlua}.

The total amount of returnable text from a \type{\directlua} command
is only limited by available system RAM. However, each separate
printed string has to fit completely in \TEX's input buffer.

\subsubsection{\function{tex.print}}

\startfunctioncall
   tex.print(<string s>, ...)
   tex.print(<number n>, <string s>, ...)
\stopfunctioncall

Each string argument is treated by \TEX\ as a separate input line.

The optional parameter can be used to print the strings using the
catcode regime defined by \type{\catcodetable} $n$. If $n$ is not
a valid catcode table, then it is ignored, and the currently
active catcode regime is used instead.

The very last string of the very last \type{tex.print()} command in a
\type{\directlua} will not have the \type{\endlinechar} appended, all 
others do.

\subsubsection{\function{tex.sprint}}

\startfunctioncall
   tex.sprint(<string s>, ...)
   tex.sprint(<number n>, <string s>, ...)
\stopfunctioncall

Each string argument is treated by \TEX\ as a special kind of input line
that makes it suitable for use as a partial line input mechanism:

\startitemize
\item \TEX\ does not switch to the `new line' state, so 
   that leading spaces are not ignored
\item no \type{\endlinechar} is inserted
\item trailing spaces are not removed
\stopitemize

\subsubsection{\function{tex.write}}

\startfunctioncall
   tex.write(<string s>, ...)
\stopfunctioncall

Each string argument is treated by \TEX\ as a special kind of input
line that makes is suitable for use as a quick way to dump
information:

\startitemize
\item all catcodes on that line are either `space' (for " ") or
     `character' (for all others).
\item there is no \type{\endlinechar} appended.
\stopitemize


\section{The \lualib{texio} library}

This library takes care of the low-level I/O interface.

\subsection{Printing functions}

\subsubsection{\function{texio.write}}

\startfunctioncall
  texio.write(string target, tring s)
  texio.write(string s)
\stopfunctioncall

Without the \type{target} argument, Writes the string to the same
location(s) \TEX\ writes messages to at this moment. If
\type{\batchmode} is in effect, it writes only to the log, 
otherwise  it writes to the log and the terminal.

The optional \type{target} can be one of three possibilities:
`term', `log' or `term and log'.

\subsubsection{\function{tex.write_nl}}

\startfunctioncall
  texio.write_nl(string target, tring s)
  texio.write_nl(string s)
\stopfunctioncall

Like \function{texio.write}, but make sure that the string s will
appear at the beginning of a line. You can use an empty string if you
only want to move to the next line.

\section{The \lualib{pdf} library}

This table contains the current \type{h} en \type{v} values that
define the location on the output page. The values can be queried 
and set using scaled points as units.

\starttyping
    pdf.v
    pdf.h
\stoptyping   

The associated function calls are

\startfunctioncall
     pdf.setv(number n)
     number n = pdf.getv()
     pdf.seth(number n)
     number n = pdf.geth()
\stopfunctioncall


It also holds a print function to write stuff to the pdf document,
to be used from within a \type{\latelua} argument.


\subsubsection{\function{pdf.print}}

\startfunctioncall
   pdf.print(<string s>)
   pdf.print(<string type>, <string s>)
\stopfunctioncall

The optional parameter can be used to mimic the behaviour of
pdfliteral: the \type{type} is \type{"direct"} or \type{"page"}.


\section{The \lualib{callback} library}

This library has functions that register, find and list callbacks.

The \lualib{callback} library is only available in lua state zero (0).

\startfunctioncall
   callback.register(string <callback name>,function <callback_func>)
   callback.register(string <callback name>,nil)
\stopfunctioncall

where the \syntax{<callback name>} is a predefined callback name, see
below.

\LUATEX\ internalizes the callback function in such a way that
it does not matter if you redefine a function accidentally.

Callback assignments are always global. You can use the special value
`nil' instead of a function for clearing the callback.

\startfunctioncall
   table <info> = callback.list()
\stopfunctioncall

The keys in the table are the known callback names, the value is a
boolean where \type{true} means that the callback is currently set
(active).

\startfunctioncall
   function <f> = callback.find(<callback name>)
\stopfunctioncall

If the callback is not set, \type{callback.find} returns \type{nil}.


\subsection{File discovery callbacks}


\subsubsection{\callback{find_read_file} and \callback{find_write_file}}

You callback function should have the following conventions:

\startfunctioncall
   string <actual_name> = function (number <id_number>, string <asked_name>)
\stopfunctioncall

Arguments:
\startitemize
\sym{id_number}   

zero for the log or \type{\input} files, or TeX's \type{\read} or
\type{\write} number incremented by one (\type{\read}0 becomes 1).

\sym{asked_name}

the user||supplied filename, as found by \type{\input}, or \type{\openin},
or \type{\openout}.
\stopitemize

Return value:
\startitemize

\sym{actual_name} 

the filename used. For the very first file that is read in by \TEX,
you have to make sure you return an \type{actual_name} that has an
extension and that is suitable for use as \type{jobname}. If you
don't, you will have to manually fix the name for the log file and
output file, and an eventual format filename will become mangled,
since these depend on the jobname.

Return \type{nil} if the file cannot be found.
\stopitemize

\subsubsection{\callback{find_font_file}}

You callback function should have the following conventions:

\startfunctioncall
   string <actual_name> = function (string <asked_name>)
\stopfunctioncall

The  \type{asked_name} is an OTF or TFM font metrics file.

Return \type{nil} if the file cannot be found.

\subsubsection{\callback{find_output_file}}

You callback function should have the following conventions:

\startfunctioncall
   string <actual_name> = function (string <asked_name>)
\stopfunctioncall

The  \type{asked_name} is the PDF or DVI file for writing.

\subsubsection{\callback{find_format_file}}

You callback function should have the following conventions:

\startfunctioncall
   string <actual_name> = function (string <asked_name>)
\stopfunctioncall

The \type{asked_name} is a format file for reading (the format file
for writing is always opened in the current directory).


\subsubsection{\callback{find_vf_file}}

Like \callback{find_font_file}, but for virtual fonts. This applies to
both Aleph's \type{ovf} files and traditional Knuthian \type{vf} files.

\subsubsection{\callback{find_ocp_file}}

Like \callback{find_font_file}, but for ocp files.

\subsubsection{\callback{find_map_file}}

Like \callback{find_font_file}, but for map files.

\subsubsection{\callback{find_enc_file}}

Like \callback{find_font_file}, but for enc files.


\subsubsection{\callback{find_sfd_file}}

Like \callback{find_font_file}, but for subfont definition files.


\subsubsection{\callback{find_pk_file}}

Like \callback{find_font_file}, but for pk bitmap files. The argument
\type{<name>} is a bit special in this case. It's form is

\starttyping
  <base res>dpi/<fontname>.<actual res>pk
\stoptyping

So you may be asked for \type{600dpi/manfnt.720pk}.  It is up to you
to find a `reasonable' bitmap file to go with that specification.

\subsubsection{\callback{find_data_file}}

Like \callback{find_font_file}, but for embedded files (\type{\pdfobj file "..."}).

\subsubsection{\callback{find_opentype_file}}

Like \callback{find_font_file}, but for opentype font files.

\subsubsection{\callback{find_truetype_file} and \callback{find_type1_file}}

You callback function should have the following conventions:

\startfunctioncall
   string <actual_name> = function (string <asked_name>)
\stopfunctioncall

The \type{asked_name} is a font file. This callback is called while
\LUATEX\ is building its internal list of needed font files, so the
actual timing may surprise you. Your return value is later fed back
into the matching \callback{read__file} callback.

Strangely enough, \type{find_type1_file} is also used for OpenType
(otf) fonts.

\subsubsection{\callback{find_image_file}}

You callback function should have the following conventions:

\startfunctioncall
   string <actual_name> = function (string <asked_name>)
\stopfunctioncall

The \type{asked_name} is an image file. Your return value is used to
open a file from the harddisk, so make sure you return something that
is considered the name of a valid file by your operating system.


\subsection{File reading callbacks}

\subsubsection{\callback{open_read_file}}

You callback function should have the following conventions:

\startfunctioncall
   table <env> = function (string <file_name>)
\stopfunctioncall

Argument:
\startitemize
\sym{file_name}

the filename returned by a previous \callback{find_read_file} or the return
value of \type{kpse_find_file()} if there was no such callback defined.
\stopitemize

Return value:
\startitemize
\sym{env}  

this is a table containing at least one required and one optional
callback functions for this file. The required field is
`\callback{reader}' and the associated function will be called once
for each new line to be read, the optional one is `\callback{close}'
that will be called once when \LUATEX\ is done with the file. 

\LUATEX\ never looks at the rest of the table, so you can use it to 
store your private per-file data. Both the callback functions will
receive the table as their only argument.
\stopitemize

\subsubsubsection{\callback{reader}}

\LUATEX\ will run this function whenever it needs a new input line 
from the file.

\startfunctioncall
  function (table <env>)
    return string <line>
  end
\stopfunctioncall

Your function should return either a string or `nil'. The value `nil'
signals that the end of file has occurred, and will make \TEX\ call
the optional `\callback{close}' function next.

\subsubsubsection{\callback{close}}

\LUATEX\ will optionally run this function when it needs to close the file.

\startfunctioncall
  function (table <env>)
    return
  end
\stopfunctioncall

Your function should not return any value.

\subsubsection{\callback{read_font_file}}

This function is called when \TEX\ needs to read a \type{ofm} or
\type{tfm} file.

\startfunctioncall
     function (string <name>)
        return boolean <success>, string <data>, number <data_size>
     end
\stopfunctioncall

\startitemize
\sym{success} 

return false when a fatal error occured (e.g. when the file cannot be
found, after all).

\sym{data} 

the bytes comprising the file. 

\sym{data_size} 

the length of the \type{data}, in bytes.
\stopitemize

return an empty string and zero if the file was found but there was a
reading problem.

\subsubsection{\callback{read_vf_file}}

Like \callback{read_font_file}, but for virtual fonts.

\subsubsection{\callback{read_ocp_file}}

Like \callback{read_font_file}, but for ocp files.

\subsubsection{\callback{read_map_file}}

Like \callback{read_font_file}, but for map files.

\subsubsection{\callback{read_enc_file}}

Like \callback{read_font_file}, but for enc files.


\subsubsection{\callback{read_sfd_file}}

Like \callback{read_font_file}, but for subfont definition files.


\subsubsection{\callback{read_pk_file}}

Like \callback{read_font_file}, but for pk bitmap files.

\subsubsection{\callback{read_data_file}}

Like \callback{read_font_file}, but for embedded files (\type{\pdfobj file "..."}).


\subsubsection{\callback{read_truetype_file}}

Like \callback{read_font_file}, but for truetype font files. The
\type{name} is a path name as returned by \callback{find_truetype_file} 
or \type{kpse_find_file}.

\subsubsection{\callback{read_type1_file}}

Like \callback{read_font_file}, but for type1 font files. The
\type{name} is a path name as returned by \callback{find_type1_file} 
or \type{kpse_find_file}.

\subsubsection{\callback{read_opentype_file}}

Like \callback{read_font_file}, but for opentype font files. The
\type{name} is a path name as returned by \callback{find_type1_file} 
or \type{kpse_find_file}.


\subsection{Data processing callbacks}


\subsubsection{\callback{process_input_buffer}}


This callback allows you to change the contents of the line input
buffer just before \LUATEX\ actually starts looking at it.

\startfunctioncall
     function (string <buffer>)
        return string <adjusted_buffer>
     end
\stopfunctioncall

If you return \type{nil}, \LUATEX\ will pretend like your callback
never happened. You can gain a small amount of processing time from
that.

\subsection{Information reporting callbacks}


\subsubsection{\callback{start_run}}

\startfunctioncall
  function ()
\stopfunctioncall

Replaces the code that prints \LUATEX's banner

\subsubsection{\callback{stop_run}}

\startfunctioncall
  function ()
\stopfunctioncall

Replaces the code that prints \LUATEX's statistics and `Output written
to' messages.

\subsubsection{\callback{start_page_number}}

\startfunctioncall
  function ()
\stopfunctioncall

Replaces the code that prints the \type{[} and the page number at the
begin of \type{\shipout}. This callback will also override the
printing of box information that normally takes place when
\type{\tracingoutput} is positive.

\subsubsection{\callback{stop_page_number}}

\startfunctioncall
  function ()
\stopfunctioncall

Replaces the code that prints the \type{]} at the end of \type{\shipout}

\subsubsection{\callback{show_error_hook}}
       
\startfunctioncall
     function ()
       return 
     end 
\stopfunctioncall

This callback is run from inside the \TEX\ error function, and the idea
is to allow you to do some extra reporting on top of what \TEX\ already
does (none of the normal actions are removed). You may find some of
the values in the \lualib{statistics} table useful.

\startitemize
\sym{message} 

is the formal error message \TEX\ has given to the user
(the line after the "! ")

\sym{indicator} 

is either a filename (when it is a string) or a location indicator (a
number) that can means lots of different things like a token list id
or a \type{\read} number.

\sym{lineno}  

is the current line number
\stopitemize

This is an investigative item only, only for 'testing the water'.

The final goal is the total replacement of \TEX's error handling
routines, but that needs lots of adjustments in the web source because
\TEX\ deals with errors in a somewhat haphazard fashion.

\subsection{Font-related callbacks}

\subsubsection{\callback{define_font}}

\startfunctioncall
     function (string <name>, string <area>, number <size>)
       return table <font>
     end 
\stopfunctioncall

The string \type{<name>} is the filename part of the font
specification, as given by the user.

The string \type{<area>} is the areaname part of the font
specification, as given by the user.

The number \type{<size>} is a bit special: 
\startitemize
\item if it is positive, it specifies an `at size' in scaled points. 
\item if it is negative, its absolute value represents a `scaled'
setting relative to the designsize of the font.
\stopitemize

The internal structure of the \type{<font>} table that is to be
returned is explained in \in{chapter}[fonts]. That table is saved
internally, so you can put extra fields in the table for your 
later lua code to use.

\section{The \lualib{lua} library}

This library contains two read-only  items:

\subsection{Variables}

\starttyping
     number n = lua.id
\stoptyping
the id number of the instance


\starttyping
     string s = lua.version
\stoptyping 
a luatex version identifier string (currently \type{"0.1"})

\subsection{Lua bytecode registers}

Lua registers can be used to communicate lua functions across lua
states. The accepted values for assignments are functions and
nil. Likewise, the retrieved value is either a function or nil.

\starttyping
     lua.bytecode[n] = function () .. end
     lua.bytecode[n]()
\stoptyping

The contents of the \type{lua.bytecode} array is stored inside the format
file as actual lua bytecode, so it can also be used to preload lua code.

The associated function calls are

\startfunctioncall
     function f = lua.getbytecode(number n)
     lua.setbytecode(number n, function f)
\stopfunctioncall


\section{The \lualib{kpse} library}

\subsection{\function{kpse.find_file}}

The most important function in the library is find_file:

\startfunctioncall
 string f = kpse.find_file(string filename)
 string f = kpse.find_file(string filename, string ftype)
 string f = kpse.find_file(string filename, boolean mustexist)
 string f = kpse.find_file(string filename, string ftype, boolean mustexist)
\stopfunctioncall


Arguments:
\startitemize
\sym{filename} 

the name of the file you want to find, with or without extension.

\sym{type} 

maps to the '-format' argument of \type{kpsewhich}.  The supported
values are:

\startcolumns
\starttyping
"gf"
"pk"
"bitmap font"
"tfm" 
"afm" 
"base" 
"bib" 
"bst" 
"cnf"
"ls-R"
"fmt"
"map"
"mem"
"mf" 
"mfpool" 
"mft" 
"mp" 
"mppool" 
"MetaPost support"
"ocp"
"ofm" 
"opl"
"otp"
"ovf"
"ovp"
"graphic/figure"
"tex"
"TeX system documentation"
"texpool"
"TeX system sources"
"PostScript header"
"Troff fonts"
"type1 fonts" 
"vf"
"dvips config"
"ist"
"truetype fonts"
"type42 fonts"
"web2c files"
"other text files"
"other binary files"
"misc fonts"
"web"
"cweb"
"enc files"
"cmap files"
"subfont definition files"
"opentype fonts"
"pdftex config"
"lig files"
"texmfscripts"
\stoptyping
\stopcolumns

The default type is \type{"tex"}.

\sym{mustexist} 

is similar to kpsewhich's '-must-exist', and the default is `false'.
If you specify `true' (or a non-zero integer), then the kpse library
will search the disk as well as the ls-R databases.
\stopitemize

\subsection{\function{kpse.expand_path}}

Like kpsewhich's  `-expand-path':

\startfunctioncall
     string r = kpse.expand_path(string s)
\stopfunctioncall

\subsection{\function{kpse.expand_var}}

Like kpsewhich's  `-expand-var':

\startfunctioncall
     string r = kpse.expand_var(string s)
\stopfunctioncall


\subsection{\function{kpse.expand_braces}}

Like kpsewhich's  `-expand-braces':

\startfunctioncall
     string r = kpse.expand_braces(string s)
\stopfunctioncall

\section{The \lualib{statistics} library}

This contains a number of run||time configuration items that
you may find useful in message reporting, as well as an iterator
function that gets all of the names and values as a table.

\startfunctioncall
   table <info> = statistics.list()
\stopfunctioncall

The keys in the table are the known items, the value is the current
value. 

Almost all of the values in \type{statistics} are fetched through a
metatable at run||time whenever they are accessed, so you cannot use
\type{pairs} on\type{statistics}, but you {\it can\/} use \type{pairs}
on \type{<info>}, of course.

If you do not need the full list, you can also ask for a single item
by using it's name as an index into \type{statistics}. 

The current list is:

\starttabulate[|l|l|]
\NC Key     \NC                  Explanation \NC\FR
\NC pdf_gone\NC                  written pdf bytes      \NC \AR
\NC pdf_ptr\NC                   not yet written pdf bytes      \NC \AR
\NC dvi_gone\NC                  written dvi bytes      \NC \AR
\NC dvi_ptr\NC                   not yet written dvi bytes      \NC \AR
\NC total_pages\NC               number of written pages      \NC \AR
\NC output_file_name\NC          name of the pdf or dvi file      \NC \AR
\NC log_name\NC                  name of the log file      \NC \AR
\NC banner\NC                    terminal display banner      \NC \AR
\NC pdftex_banner\NC             --      \NC \AR
\NC var_used\NC                  variable (one-word) memory in use \NC \AR
\NC dyn_used\NC                  token (multi-word) memory in use  \NC \AR
\NC str_ptr\NC                   number of strings      \NC \AR
\NC init_str_ptr\NC              number of initex strings      \NC \AR
\NC max_strings\NC               maximum allowed strings      \NC \AR
\NC pool_ptr\NC                  string pool index      \NC \AR
\NC init_pool_ptr\NC             initex string pool index      \NC \AR
\NC pool_size\NC                 maximum allowed string characters      \NC \AR
\NC lo_mem_max\NC                current top of multi-word memory      \NC \AR
\NC mem_min\NC                   bottom index of memory array     \NC \AR
\NC mem_end\NC                   top index of memory array      \NC \AR
\NC hi_mem_min\NC                current bottom of one-word memory      \NC \AR
\NC cs_count\NC                  number of control sequences      \NC \AR
\NC hash_size\NC                 size of hash       \NC \AR
\NC hash_extra\NC                extra allowed hash  \NC \AR
\NC font_ptr\NC                  number of active fonts      \NC \AR
\NC hyph_count\NC                hyphenation exceptions      \NC \AR
\NC hyph_size\NC                 max used hyphenation exceptions  \NC \AR
\NC max_in_stack\NC              max used input stack entries      \NC \AR
\NC max_nest_stack\NC            max used nesting stack entries     \NC \AR
\NC max_param_stack\NC           max used parameter stack entries     \NC \AR
\NC max_buf_stack\NC             max used buffer position      \NC \AR
\NC max_save_stack\NC            max used save stack entries      \NC \AR
\NC stack_size\NC                input stack size      \NC \AR
\NC nest_size\NC                 nesting stack size      \NC \AR
\NC param_size\NC                parameter stack size      \NC \AR
\NC buf_size\NC                  line buffer size      \NC \AR
\NC save_size\NC                 save stack size      \NC \AR
\NC obj_ptr\NC                   max pdf object pointer      \NC \AR
\NC obj_tab_size\NC              pdf object table size      \NC \AR
\NC pdf_os_cntr\NC               max pdf object stream pointer      \NC \AR
\NC pdf_os_objidx\NC             pdf object stream index \NC \AR
\NC pdf_dest_names_ptr\NC        max pdf destination pointer       \NC \AR
\NC dest_names_size\NC           pdf destination table size      \NC \AR
\NC pdf_mem_ptr\NC               max pdf memory used      \NC \AR
\NC pdf_mem_size\NC              pdf memory size      \NC \AR
\NC largest_used_mark\NC         max referenced marks class        \NC \AR
\NC filename\NC                  name of the current input file    \NC \AR
\NC inputid\NC                   numeric id of the current input    \NC \AR
\NC linenumber\NC                location in the current input file\NC\AR
\NC lasterrorstring\NC           last error string\NC \AR
\NC luabytecodes\NC              number of active luabytecode registers\NC\AR
\NC luabytecode_bytes\NC         number of bytes in luabytecode registers\NC\AR
\NC luastates\NC                 number of active lua interpreters\NC\AR
\NC luastate_bytes\NC            number of bytes in use by lua interpreters\NC\AR
\stoptabulate


\section{The \lualib{texconfig} table}

This is a table that is created empty. A startup lua script could
fill this table with a number of settings that are read out by
the executable after loading and executing the startup file. 


\starttabulate[|l|l|l|p|]
\NC key      \NC type     \NC default \NC explanation \NC\FR
\NC mem_bot \NC 	        number\NC  0\NC cf. web2c docs \NC \AR     
\NC main_memory \NC        number\NC  250000\NC cf. web2c docs \NC \AR
\NC extra_mem_top \NC      number\NC  0\NC cf. web2c docs \NC \AR     
\NC extra_mem_bot \NC      number\NC  0\NC cf. web2c docs \NC \AR     
\NC pool_size \NC 	        number\NC  100000\NC cf. web2c docs \NC \AR
\NC string_vacancies \NC   number\NC  75000\NC cf. web2c docs \NC \AR 
\NC pool_free \NC 	        number\NC  5000\NC cf. web2c docs \NC \AR  
\NC max_strings \NC        number\NC  15000\NC cf. web2c docs \NC \AR 
\NC strings_free \NC       number\NC  100\NC cf. web2c docs \NC \AR   
\NC trie_size \NC 	        number\NC  20000\NC cf. web2c docs \NC \AR 
\NC hyph_size \NC 	        number\NC  659\NC cf. web2c docs \NC \AR   
\NC buf_size \NC 	        number\NC  3000\NC cf. web2c docs \NC \AR  
\NC nest_size \NC 	        number\NC  50\NC cf. web2c docs \NC \AR    
\NC max_in_open \NC        number\NC  15\NC cf. web2c docs \NC \AR    
\NC param_size \NC         number\NC  60\NC cf. web2c docs \NC \AR    
\NC save_size \NC 	        number\NC  4000\NC cf. web2c docs \NC \AR  
\NC stack_size \NC         number\NC  300\NC cf. web2c docs \NC \AR   
\NC dvi_buf_size \NC       number\NC  16384\NC cf. web2c docs \NC \AR 
\NC error_line \NC         number\NC  79\NC cf. web2c docs \NC \AR    
\NC half_error_line \NC    number\NC  50\NC cf. web2c docs \NC \AR    
\NC max_print_line \NC     number\NC  79\NC cf. web2c docs \NC \AR    
\NC ocp_list_size \NC      number\NC 1000\NC cf. web2c docs \NC \AR   
\NC ocp_buf_size \NC       number\NC 1000\NC cf. web2c docs \NC \AR   
\NC ocp_stack_size \NC     number\NC 1000\NC cf. web2c docs \NC \AR   
\NC hash_extra \NC         number\NC  0\NC cf. web2c docs \NC \AR     
\NC pk_dpi \NC             number\NC  72\NC cf. web2c docs \NC \AR    
\NC kpse_init \NC boolean \NC true    \NC \type{false} totally disables Kpathsea initialisation
                                          (only ever unset this if you implement {\it all\/} file
                                          find callbacks!)\NC\AR
\NC trace_file_names \NC boolean \NC true \NC \type{false} disables TeX's normal file open||close 
                                              feedback (the assumption is that callbacks will take care of 
	                                      that). \NC \AR
\NC src_special_auto  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everypar  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everyparend  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everycr  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everymath  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everyhbox  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everyvbox  \NC boolean \NC false \NC Source specials sub-item \NC\AR
\NC src_special_everydisplay  \NC boolean \NC false \NC Source specials sub-item \NC\AR

\NC file_line_error  \NC boolean \NC false \NC Do \type{file:line} style error messages\NC\AR
\NC halt_on_error    \NC boolean \NC false \NC Abort run on the first encountered error\NC\AR
\NC formatname       \NC string \NC -- \NC If no format name was given
                                             on the command--line, this key will be tested first 
                                             instead of simply quitting\NC\AR
\NC jobname          \NC string \NC -- \NC If no input file name was given
                                           on the command--line, this key will be tested first 
                                           instead of simply giving up\NC\AR
\stoptabulate

\section{The \lualib{font} library}

The font library will provide the interface into the internals of the
font system, as well as contain some binary font loaders. 


\subsection{Loading a tfm file}

\startfunctioncall
     table fnt = font.read_tfm(string name, number s)
\stopfunctioncall

The number is a bit special: 
\startitemize
\item if it is positive, it specifies an `at size' in scaled points. 
\item if it is negative, its absolute value represents a `scaled'
setting relative to the designsize of the font.
\stopitemize

The internal structure of the virtual font table that is returned is
explained in \in{chapter}[fonts].


\subsection{Loading a vf file}

\startfunctioncall
     table vf_fnt = font.read_vf(string name, number s)
\stopfunctioncall

The number is a bit special: 
\startitemize
\item if it is positive, it specifies an `at size' in scaled points. 
\item if it is negative, its absolute value represents a `scaled'
setting relative to the designsize of the font.
\stopitemize


\subsection{Loading an opentype or truetype file}

If you want to use an OpenType font, you have to get the metric
information from somewhere. The next two functions provide a way of
doing that. 

\startfunctioncall
     table ttf_metrics = font.read_otf(string filename)
     table ttf_metrics = font.read_ttf(string filename)
\stopfunctioncall

The result is identical in both cases, but you have to use the
`read_otf' for loading of information from PostScript-based OpenType
and `read_ttf' for loading of TrueType-based OpenType (or simply a
TrueType font). Bitmap-only OpenType fonts are not supported.

At the moment, the \type{filename} font file is actually parsed and
even partially interpreted by the OpenType/TrueType loading routines
from FontForge. There are a few reasons for this:

\startitemize
\item The font is automatically re-encoded, so that the \type{ttf_metrics} 
   table is using unicode for the character indices.
\item Many features are pre-processed into a format that is easier to handle
   than just the bare tables would be.
\item PostScript-based OpenType fonts do not store the character height and 
  depth in the font file, so the actual character boundingbox has to be 
  calculated.
\item In the future, it may be interesting to allow Lua scripts access to 
  the actual font programs.
\stopitemize

The top||level keys in the returned table are (this documentation is
not yet finished):

\starttabulate[|l|l|p|]
\NC key                          \NC type     \NC explanation \NC\FR
\NC fontname                     \NC string   \NC \NC\NR
\NC fullname                     \NC string   \NC \NC\NR
\NC familyname                   \NC string   \NC \NC\NR
\NC weight                       \NC string   \NC \NC\NR
\NC copyright                    \NC string   \NC \NC\NR
\NC filename                     \NC string   \NC \NC\NR
\NC defbasefilename              \NC string   \NC \NC\NR
\NC version                      \NC string   \NC \NC\NR
\NC italicangle                  \NC float    \NC \NC\NR
\NC upos                         \NC float    \NC \NC\NR
\NC uwidth                       \NC float    \NC \NC\NR
\NC ascent                       \NC number   \NC \NC\NR
\NC descent                      \NC number   \NC \NC\NR
\NC vertical_origin              \NC number   \NC \NC\NR
\NC uniqueid                     \NC number   \NC \NC\NR
\NC glyphcnt                     \NC number   \NC \NC\NR
\NC glyphmax                     \NC number   \NC \NC\NR
\NC glyphs                       \NC array    \NC \NC\NR
\NC changed                      \NC number   \NC \NC\NR
\NC hasvmetrics                  \NC number   \NC \NC\NR
\NC order2                       \NC number   \NC \NC\NR
\NC strokedfont                  \NC number   \NC \NC\NR
\NC weight_width_slope_only      \NC number   \NC \NC\NR
\NC head_optimized_for_cleartype \NC number   \NC \NC\NR
\NC uni_interp                   \NC enum     \NC Possible values:  "unset", "none", "adobe", "greek", "japanese",
                                                  "trad_chinese", "simp_chinese", "korean", "ams"\NC\NR
\NC map                          \NC table    \NC \NC\NR
\NC private                      \NC table    \NC \NC\NR
\NC xuid                         \NC string   \NC \NC\NR
\NC pfminfo                      \NC table    \NC \NC\NR
\NC names                        \NC table    \NC \NC\NR
\NC cidinfo                      \NC table    \NC \NC\NR
\NC subfonts                     \NC array    \NC \NC\NR
\NC cidmaster                    \NC array    \NC \NC\NR
\NC commments                    \NC string   \NC \NC\NR
\NC anchor                       \NC table    \NC \NC\NR
\NC orders                       \NC table    \NC \NC\NR
\NC ttf_tables                   \NC table    \NC \NC\NR
%\NC ttf_tab_saved                \NC table    \NC \NC\NR
\NC script_lang                  \NC table    \NC \NC\NR
\NC kerns                        \NC table    \NC \NC\NR
\NC vkerns                       \NC table    \NC \NC\NR
\NC texdata                      \NC table    \NC \NC\NR
\NC tt_cur                       \NC number   \NC \NC\NR
\NC tt_max                       \NC number   \NC \NC\NR
\NC gentags                      \NC table    \NC \NC\NR
\NC possub                       \NC table    \NC \NC\NR
\NC features                     \NC table    \NC \NC\NR
\NC chosenname                   \NC string   \NC \NC\NR
\NC macstyle                     \NC number   \NC \NC\NR
\NC sli_cnt                      \NC number   \NC \NC\NR
\NC fondname                     \NC string   \NC \NC\NR
\NC design_size                  \NC number   \NC \NC\NR
\NC fontstyle_id                 \NC number   \NC \NC\NR
\NC fontstyle_name               \NC table    \NC \NC\NR
\NC design_range_bottom          \NC number   \NC \NC\NR
\NC design_range_top             \NC number   \NC \NC\NR
\NC strokewidth                  \NC float    \NC \NC\NR
\NC mark_class_cnt               \NC number   \NC \NC\NR
\NC mark_classes                 \NC array    \NC \NC\NR
\NC mark_class_names             \NC array    \NC \NC\NR
\NC creationtime                 \NC number   \NC \NC\NR
\NC modificationtime             \NC number   \NC \NC\NR
\NC os2_version                  \NC number   \NC \NC\NR
\NC gasp_version                 \NC number   \NC \NC\NR
\NC gasp_cnt                     \NC number   \NC \NC\NR
\NC gasp                         \NC table    \NC \NC\NR
\stoptabulate


\subsubsection{Glyph items}

The \type{glyphs} is an array containing the per-character information.

\starttabulate[|l|l|p|]
\NC key                          \NC type     \NC explanation \NC\FR
\NC name                         \NC string   \NC \NC\NR
\NC unicodeenc                   \NC number   \NC \NC\NR
\NC boundingbox                  \NC array    \NC Array of four numbers\NC\NR
\NC orig_pos                     \NC number   \NC \NC\NR
\NC width                        \NC number   \NC \NC\NR
\NC vwidth                       \NC number   \NC \NC\NR
\NC lsidebearing                 \NC number   \NC \NC\NR
\NC ticked                       \NC number   \NC \NC\NR
\NC widthset                     \NC number   \NC \NC\NR
\NC glyph_class                  \NC number   \NC \NC\NR
\NC kerns                        \NC array    \NC \NC\NR
\NC vkerns                       \NC array    \NC \NC\NR
\NC dependents                   \NC array    \NC Linear array of glyph name strings\NC\NR
\NC possub                       \NC table    \NC \NC\NR
\NC ligofme                      \NC table    \NC \NC\NR
\NC comment                      \NC string   \NC \NC\NR
\NC color                        \NC number   \NC \NC\NR
\NC tex_height                   \NC number   \NC \NC\NR
\NC tex_depth                    \NC number   \NC \NC\NR
\NC tex_sub_pos                  \NC number   \NC \NC\NR
\NC tex_super_pos                \NC number   \NC \NC\NR
\stoptabulate

The \type{kerns} and \type{vkerns} are linear arrays of small hashes:

\starttabulate[|l|l|p|]
\NC key                          \NC type     \NC explanation \NC\FR
\NC char                         \NC string   \NC \NC\NR
\NC off                          \NC number   \NC \NC\NR
\NC sli                          \NC number   \NC \NC\NR
\NC flags                        \NC number   \NC \NC\NR
\stoptabulate

The \type{possub} is a linear array of small hashes:
\starttabulate[|l|l|p|]
\NC key                          \NC type     \NC explanation \NC\FR
\NC type                         \NC enum     \NC "position", "pair",  "substitution", "alternate",
                                                  "multiple", "ligature", "lcaret",  "kerning", "vkerning", "anchors",
                                                  "contextpos", "contextsub", "chainpos", "chainsub",
                                                  "reversesub", "max", "kernback", "vkernback" \NC\NR
\NC macfeature                   \NC number   \NC \NC\NR
\NC flags                        \NC number   \NC \NC\NR
\NC tag                          \NC string   \NC \NC\NR
\NC script_lang_index            \NC number   \NC \NC\NR
\stoptabulate

For the first seven values of \type{type}, there can be additional sub-information:
\starttabulate[|l|l|l|p|]
\NC value        \NC key                \NC type     \NC explanation \NC\FR
\NC position     \NC pos                \NC table    \NC `vr' table\NC\NR
\NC pair         \NC pair               \NC table    \NC one string: 'paired', and a 'vr' (sub)table\NC\NR
\NC substitution \NC subs               \NC table    \NC one string: 'variant'\NC\NR
\NC alternate    \NC alt                \NC table    \NC one string: 'components'\NC\NR
\NC multiple     \NC mult               \NC table    \NC one string: 'components'\NC\NR
\NC ligature     \NC lig                \NC table    \NC two strings: 'components', 'char'\NC\NR
\NC lcaret       \NC lcaret             \NC array    \NC linear array of numbers\NC\NR
\stoptabulate
The `vr' table contains for number-valued fields: \type{xoff},
\type{yoff}, \type{h_adv_off} and \type{v_adv_off}.

The other values of \type{type} could probably use some extra
information as well, but I do not know which case of the union is
supposed to be selected.


The \type{ligofme} is a linear array of small hashes:
\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
\NC lig                \NC table    \NC uses the same substructure as a single `possub' item\NC\NR
\NC char               \NC string   \NC \NC\NR
\NC components         \NC array    \NC linear array of named components\NC\NR
\NC ccnt               \NC number   \NC \NC\NR
\stoptabulate

\subsubsection{map table}

The top-level map is a list of encoding mappings. Each of those is a table itself.

\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
\NC enccount           \NC number   \NC \NC\NR
\NC encmax             \NC number   \NC \NC\NR
\NC backmax            \NC number   \NC \NC\NR
\NC ticked             \NC number   \NC \NC\NR
\NC remap              \NC table    \NC \NC\NR
\NC map                \NC array    \NC non-linear array of mappings\NC\NR
\NC backmap            \NC array    \NC non-linear array of backward mappings\NC\NR
\NC enc                \NC table    \NC \NC\NR
\stoptabulate

The `remap' table is very small:
\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
\NC firstenc           \NC number   \NC \NC\NR
\NC lastenc            \NC number   \NC \NC\NR
\NC infont             \NC number   \NC \NC\NR
\stoptabulate

The `enc' table is a bit more verbose:
\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
\NC enc_name           \NC string   \NC \NC\NR
\NC char_cnt           \NC number   \NC \NC\NR
\NC char_max           \NC number   \NC \NC\NR
\NC unicode            \NC array    \NC of unicode position numbers\NC\NR
\NC psnames            \NC array    \NC of postscript glyph names\NC\NR
\NC builtin            \NC number   \NC \NC\NR
\NC hidden             \NC number   \NC \NC\NR
\NC only_1byte         \NC number   \NC \NC\NR
\NC has_1byte          \NC number   \NC \NC\NR
\NC has_2byte          \NC number   \NC \NC\NR
\NC is_unicodebmp      \NC number   \NC \NC\NR
\NC is_unicodefull     \NC number   \NC \NC\NR
\NC is_custom          \NC number   \NC \NC\NR
\NC is_original        \NC number   \NC \NC\NR
\NC is_compact         \NC number   \NC \NC\NR
\NC is_japanese        \NC number   \NC \NC\NR
\NC is_korean          \NC number   \NC \NC\NR
\NC is_tradchinese     \NC number   \NC \NC\NR
\NC is_simplechinese   \NC number   \NC \NC\NR
\NC low_page           \NC number   \NC \NC\NR
\NC high_page          \NC number   \NC \NC\NR
\NC is_temporary       \NC number   \NC \NC\NR
\NC iconv_name         \NC string   \NC \NC\NR
\NC iso_2022_escape    \NC string   \NC \NC\NR
\stoptabulate

\subsubsection{private table}

This is the font's private PostScript dictionary, if any. Keys and
values are both strings.


\subsubsection{cidinfo table}

\starttabulate[|l|l|p|]
\NC registry                  \NC string   \NC \NC\NR
\NC ordering                  \NC string   \NC \NC\NR
\NC supplement                \NC number   \NC \NC\NR
\NC version                   \NC number   \NC \NC\NR
\stoptabulate

\subsubsection{pfminfo table}

The `pfminfo' table contains most of the OS/2 information:

\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
\NC pfmset             \NC number  \NC \NC\NR
\NC winascent_add      \NC number  \NC \NC\NR
\NC windescent_add     \NC number  \NC \NC\NR
\NC hheadascent_add    \NC number  \NC \NC\NR
\NC hheaddescent_add   \NC number  \NC \NC\NR
\NC typoascent_add     \NC number  \NC \NC\NR
\NC typodescent_add    \NC number  \NC \NC\NR
\NC subsuper_set       \NC number  \NC \NC\NR
\NC panose_set         \NC number  \NC \NC\NR
\NC hheadset           \NC number  \NC \NC\NR
\NC vheadset           \NC number  \NC \NC\NR
\NC pfmfamily          \NC number  \NC \NC\NR
\NC weight             \NC number  \NC \NC\NR
\NC width              \NC number  \NC \NC\NR
\NC avgwidth           \NC number  \NC \NC\NR
\NC firstchar          \NC number  \NC \NC\NR
\NC lastchar           \NC number  \NC \NC\NR
\NC fstype             \NC number  \NC \NC\NR
\NC linegap            \NC number  \NC \NC\NR
\NC vlinegap           \NC number  \NC \NC\NR
\NC hhead_ascent       \NC number  \NC \NC\NR
\NC hhead_descent      \NC number  \NC \NC\NR
\NC hhead_descent      \NC number  \NC \NC\NR
\NC os2_typoascent     \NC number  \NC \NC\NR
\NC os2_typodescent    \NC number  \NC \NC\NR
\NC os2_typolinegap    \NC number  \NC \NC\NR
\NC os2_winascent      \NC number  \NC \NC\NR
\NC os2_windescent     \NC number  \NC \NC\NR
\NC os2_subxsize       \NC number  \NC \NC\NR
\NC os2_subysize       \NC number  \NC \NC\NR
\NC os2_subxoff        \NC number  \NC \NC\NR
\NC os2_subyoff        \NC number  \NC \NC\NR
\NC os2_supxsize       \NC number  \NC \NC\NR
\NC os2_supysize       \NC number  \NC \NC\NR
\NC os2_supxoff        \NC number  \NC \NC\NR
\NC os2_supyoff        \NC number  \NC \NC\NR
\NC os2_strikeysize    \NC number  \NC \NC\NR
\NC os2_strikeypos     \NC number  \NC \NC\NR
\NC os2_family_class   \NC number  \NC \NC\NR
\NC os2_xheight        \NC number  \NC \NC\NR
\NC os2_capheight      \NC number  \NC \NC\NR
\NC os2_defaultchar    \NC number  \NC \NC\NR
\NC os2_breakchar      \NC number  \NC \NC\NR
\NC os2_vendor         \NC string  \NC \NC\NR  
\NC panose             \NC table  \NC \NC\NR  
\stoptabulate

The \type{panose} subtable has exactly 10 string keys:
\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
familytype             \NC string   \NC Values as in the OpenType font specification: 
                   "Any", "No Fit", "Text and Display", "Script", "Decorative", "Pictorial"\NC\NR
serifstyle             \NC string   \NC See the OpenType font specification for values\NC\NR
weight                 \NC string   \NC id. \NC\NR
proportion             \NC string   \NC id. \NC\NR
contrast               \NC string   \NC id. \NC\NR
strokevariation        \NC string   \NC id. \NC\NR
armstyle               \NC string   \NC id. \NC\NR
letterform             \NC string   \NC id. \NC\NR
midline                \NC string   \NC id. \NC\NR
xheight                \NC string   \NC id. \NC\NR
\stoptabulate

\subsubsection{names table}

Each item has two top-level keys:

\starttabulate[|l|l|p|]
\NC key                \NC type     \NC explanation \NC\FR
lang                   \NC number   \NC language for this entry \NC\NR
names                  \NC table    \NC \NC\NR
\stoptabulate

The \type{names} keys are the actual TrueType name strings. The
possible keys are:
\starttabulate[|l|p|]
\NC key               \NC explanation \NC\FR
\NC copyright   \NC \NC\NR 
\NC family   \NC \NC\NR 
\NC subfamily   \NC \NC\NR 
\NC uniqueid   \NC \NC\NR
\NC fullname   \NC \NC\NR 
\NC version   \NC \NC\NR 
\NC postscriptname   \NC \NC\NR 
\NC trademark   \NC \NC\NR
\NC manufacturer   \NC \NC\NR 
\NC designer   \NC \NC\NR 
\NC descriptor   \NC \NC\NR
\NC venderurl   \NC \NC\NR
\NC designerurl   \NC \NC\NR 
\NC license   \NC \NC\NR 
\NC licenseurl   \NC \NC\NR 
\NC idontknow   \NC \NC\NR
\NC preffamilyname   \NC \NC\NR 
\NC prefmodifiers   \NC \NC\NR 
\NC compatfull   \NC \NC\NR 
\NC sampletext   \NC \NC\NR
\NC cidfindfontname   \NC \NC\NR
\stoptabulate

\subsubsection{anchor table}

The anchor classes:

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC name                   \NC string   \NC \NC\NR
\NC feature_tag            \NC string   \NC \NC\NR
\NC script_lang_index      \NC number   \NC \NC\NR
\NC flags                  \NC number   \NC \NC\NR
\NC merge_with             \NC number   \NC \NC\NR
\NC type                   \NC number   \NC \NC\NR
\NC processed              \NC number   \NC \NC\NR
\NC has_mark               \NC number   \NC \NC\NR
\NC matches                \NC number   \NC \NC\NR
\NC ac_num                 \NC number   \NC \NC\NR
\stoptabulate

\subsubsection{orders table}

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC table_tag              \NC string   \NC \NC\NR
\NC ordered_features       \NC array    \NC list of tag strings\NC\NR
\stoptabulate

\subsubsection{ttf_tables table}

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC tag                    \NC string   \NC \NC\NR
\NC len                    \NC number   \NC \NC\NR
\NC maxlen                 \NC number   \NC \NC\NR
\NC data                   \NC number   \NC \NC\NR
\stoptabulate

\subsubsection{script_lang table}

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC script                 \NC string   \NC \NC\NR
\NC langs                  \NC array    \NC list of language tags\NC\NR
\stoptabulate

\subsubsection{kerns table}

Substructure is identical to the per-glyph subtable.

\subsubsection{vkerns table}

Substructure is identical to the per-glyph subtable.

\subsubsection{texdata table}


\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC type                   \NC string   \NC possible values: "unset", "text", "math", "mathext"\NC\NR
\NC params                 \NC array    \NC 22 font numeric parameters\NC\NR
\stoptabulate

\subsubsection{gentags table}

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC tagtype                \NC array    \NC \NC\NR
\stoptabulate

The array items are mini-hashes:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC type                   \NC enum     \NC allowed values: "null", "position", "pair",  "substitution", "alternate",
  "multiple", "ligature", "lcaret",  "kerning", "vkerning", "anchors",
  "contextpos", "contextsub", "chainpos", "chainsub",
  "reversesub", "max", "kernback", "vkernback"\NC\NR
\NC tag                    \NC string   \NC \NC\NR
\stoptabulate


\subsubsection{possub table}

Top-level \type{possub} is quite different from the ones at character level.

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC type                   \NC number   \NC \NC\NR
\NC format                 \NC enum     \NC Possible values:  "glyphs", "class","coverage","reversecoverage" \NC\NR
\NC script_lang_index      \NC number   \NC \NC\NR
\NC flags                  \NC number   \NC \NC\NR
\NC tag                    \NC string   \NC \NC\NR
\NC nccnt                  \NC number   \NC \NC\NR
\NC bccnt                  \NC number   \NC \NC\NR
\NC fccnt                  \NC number   \NC \NC\NR
\NC rule_cnt               \NC number   \NC \NC\NR
\NC nclass                 \NC array   \NC \NC\NR
\NC bclass                 \NC array   \NC \NC\NR
\NC fclass                 \NC array   \NC \NC\NR
\NC rules                  \NC array   \NC an array of rule items\NC\NR
\NC ticked                 \NC number   \NC \NC\NR
\stoptabulate

Rule items have one common item and one specialized item:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC lookups                \NC array    \NC A list of `lookup items'\NC\NR
\NC glyph                  \NC array     \NC Only if the parent's format is 'glyph'\NC\NR
\NC class                  \NC array     \NC Only if the parent's format is 'glyph'\NC\NR
\NC coverage               \NC array     \NC Only if the parent's format is 'glyph'\NC\NR
\NC rcoverage              \NC array     \NC Only if the parent's format is 'glyph'\NC\NR
\stoptabulate

Each of the lookup item is:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC seq                    \NC number   \NC \NC\NR
\NC lookup_tag             \NC string   \NC \NC\NR
\stoptabulate

glyph:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC names                  \NC string   \NC \NC\NR
\NC back                   \NC string   \NC \NC\NR
\NC fore                   \NC string   \NC \NC\NR
\stoptabulate


class:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC nclasses               \NC array    \NC of numbers \NC\NR
\NC bclasses               \NC array    \NC of numbers  \NC\NR
\NC fclasses               \NC array    \NC of numbers  \NC\NR
\stoptabulate

coverage:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC ncovers                \NC array    \NC of strings \NC\NR
\NC bcovers                \NC array    \NC of strings\NC\NR
\NC fcovers                \NC array    \NC of strings \NC\NR
\stoptabulate

rcoverage:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC ncovers                \NC array    \NC of strings \NC\NR
\NC bcovers                \NC array    \NC of strings\NC\NR
\NC fcovers                \NC array    \NC of strings \NC\NR
\NC replacements           \NC string   \NC \NC\NR
\stoptabulate

\subsubsection{features table}
 
These are Apple features.

\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC feature                \NC number   \NC \NC\NR
\NC ismutex                \NC number   \NC \NC\NR
\NC default_setting        \NC number   \NC \NC\NR
\NC strid                  \NC number   \NC \NC\NR
\NC featname               \NC array    \NC array of `macname' items\NC\NR
\NC settings               \NC array    \NC \NC\NR
\stoptabulate

The \type{settings} items are hashes:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC setting                \NC number   \NC \NC\NR
\NC strid                  \NC number   \NC \NC\NR
\NC initially_enabled      \NC number   \NC \NC\NR
\NC setname                \NC array    \NC array of `macname' items\NC\NR
\stoptabulate

The `macname' hashes:
\starttabulate[|l|l|p|]
\NC key                    \NC type     \NC explanation \NC\FR
\NC enc                    \NC number   \NC \NC\NR
\NC lang                   \NC number   \NC \NC\NR
\NC name                   \NC string   \NC \NC\NR
\stoptabulate


\subsection{Loading opentype or truetype name information}

\startfunctioncall
     table ttf_info    = font.read_otf_info(string name)
     table ttf_info    = font.read_ttf_info(string name)
\stopfunctioncall

These two functions are very similar to the two commands from previous
section, but they only return a small subset of the information. The
returned table only has four keys: \type{fontname}, \type{fullname},
\type{familyname} and \type{weight}. 


\subsection{The fonts array}

\starttyping
     font.fonts[n] = { ... }
     table f = font.fonts[n]
\stoptyping

See \in{chapter}[fonts] for the structure of the tables.

The associated function calls are

\startfunctioncall
     table f = font.getfont(number n)
     font.setfont(number n, table f)
\stopfunctioncall

Note the following: Assignments can only be made to fonts that have
already be defined in \TeX, but have not been accessed {\it at all\/} since
that definition. This limits the usability of the write access to
font.fonts quite a lot, a less stringent ruleset will be implemented
later.

\subsection{Checking a font's status}

You can test for the status of a font by calling this function:

\startfunctioncall
     boolean f = font.frozen(number n)
\stopfunctioncall

The return value is one of true (unassignable), false (can be changed)
or nil (not a valid font at all).

\subsection{Defining a font directly}

You can define your own font into \type{font.fonts}

\startfunctioncall
     number i = font.define(table f)
\stopfunctioncall

The return value is the internal id number of the defined font (the
index into \type{font.fonts}). If the font creation fails, an error is
raised. The table is a font structure, as explained in
\in{chapter}[fonts].

The value of this function is debatable, because there is no direct
way of accessing the newly defined font, except from Lua code.

\chapter[fonts]{Font structure}

All \TeX\ fonts are represented to Lua code as tables, an internally
as C structures. All keys in the table below are saved in the internal
font structure if they are present in the table returned by the
`define_font' callback, or if they result from the normal tfm/vf 
reading routines if there is no `define_font' callback defined.

The column `from VF' means that this key will be created by the
`font.read_vf()' routine, `from TFM' means that the key will be created
by the `font.read_tfm()' routine, and `used' means whether or not the
luatex engine itself will do something with the key.


The top-level keys in the table are as follows:

\starttabulate[|l|l|l|l|l|p|]
\NC key                \NC from VF  \NC from TFM \NC used\NC value type \NC description \NC\FR
\NC name               \NC yes      \NC yes      \NC yes \NC string \NC metric (file) name\NC\NR
\NC area               \NC no       \NC yes      \NC yes \NC string \NC (directory)location, typically empty\NC\NR
\NC used               \NC no       \NC yes      \NC yes \NC boolean\NC used already? (initial: false)\NC \NR
\NC characters         \NC yes      \NC yes      \NC yes \NC table  \NC the defined glyphs of this font \NC \NR
\NC checksum           \NC yes      \NC yes      \NC no  \NC number \NC default: 0 \NC \NR
\NC designsize         \NC no       \NC yes      \NC yes \NC number \NC expected size (default: 655360 == 10pt) \NC \NR
\NC direction          \NC no       \NC yes      \NC yes \NC number \NC default: 0 (LTR) \NR
\NC encodingname       \NC no       \NC no       \NC yes \NC string \NC encoding name\NC\NR
\NC fonts              \NC yes      \NC no       \NC yes \NC table  \NC locally used fonts\NC \NR
\NC fullname           \NC no       \NC no       \NC yes \NC string \NC actual (PostScript) name\NC\NR
\NC header             \NC yes      \NC no       \NC no  \NC string \NC header comments, if any\NC \NR
\NC hyphenchar         \NC no       \NC no       \NC yes \NC number \NC default: TeX's \type{\hyphenchar} \NC \NR
\NC parameters         \NC no       \NC yes      \NC yes \NC hash   \NC default: 7 parameters, all zero \NC \NR
\NC size               \NC no       \NC yes      \NC yes \NC number \NC loaded (at) size. (default: same as designsize) \NC \NR
\NC skewchar           \NC no       \NC no       \NC yes \NC number \NC default: TeX's \type{\skewchar}  \NC \NR
\NC type               \NC yes      \NC no       \NC yes \NC string \NC basic type of this font\NC \NR
\NC format             \NC no       \NC no       \NC yes \NC string \NC disk format type\NC \NR
\NC embedding          \NC no       \NC no       \NC yes \NC string \NC PDF inclusion\NC \NR
\NC filename           \NC no       \NC no       \NC yes \NC string \NC disk file name\NC\NR
\stoptabulate

The key \type{name} is always required.

The key \type{used} is set by the engine when a font is actively in
use, this makes sure that the font's definition is written to the
output file (DVI or PDF). The \type{TFM} reader sets it to false.

The \type{direction} is a number signalling the `normal' direction for
this font. There are sixteen possibilities:

\starttabulate[|l|p|l|p|]
\NC number  \NC   meaning \NC  number \NC   meaning \NC\NR
\NC 0       \NC LT        \NC 8       \NC TT        \NC\NR
\NC 1       \NC LL        \NC 9       \NC TL        \NC\NR
\NC 2       \NC LB        \NC 10      \NC TB        \NC\NR
\NC 3       \NC LR        \NC 11      \NC TR        \NC\NR
\NC 4       \NC RT        \NC 12      \NC BT        \NC\NR
\NC 5       \NC RL        \NC 13      \NC BL        \NC\NR
\NC 6       \NC RB        \NC 14      \NC BB        \NC\NR
\NC 7       \NC RR        \NC 15      \NC BR        \NC\NR
\stoptabulate
These are Omega-style direction abbreviations: the first character
indicates the `first' edge of the character glyphs (the edge that is
seen first in the writing direction), the second the `top' side.

The \type{parameters} is a hash with mixed key types. There are seven
possible string keys, as well as a number of integer indices (these
start from 8 up). The seven strings are actually used instead of the
bottom seven indices, because that gives a nicer user interface.

The names and their internal remapping:
\starttabulate[|l|p|]
\NC name          \NC internal remapped number \NC\FR
\NC slant         \NC 1  \NC\NR
\NC space         \NC 2  \NC\NR
\NC space_stretch \NC 3  \NC\NR
\NC space_shrink  \NC 4  \NC\NR
\NC x_height      \NC 5  \NC\NR
\NC quad          \NC 6  \NC\NR
\NC extra_space   \NC 7  \NC\LR
\stoptabulate

The keys \type{type}, \type{format}, \type{embedding}, \type{fullname} and
\type{filename} are used to embed OpenType fonts in the result PDF.

The \type{characters} table is a list of character hashes indexed by 
integer number. The number is the `internal code' TeX knows this 
character by.

Two very special string indexes can be used also: \type{left_boundary} is a 
virtual character whose 'ligatures and 'kerns' are used to handle word 
boundary processing. \type{right_boundary} is similar but not actually
used for anything (yet!).

Other index keys are ignored. 

Each character hash itself is a hash. For example, here is the
character `f' (decimal 102) in the font cmr10 at 10 points:

\starttyping
    [102] = {
      ["kerns"] = {
        [63] = 50973,
        [93] = 50973,
        [39] = 50973,
        [33] = 50973,
        [41] = 50973
       },
      ["italic"] = 50973,
      ["height"] = 455111,
      ["depth"] = 0,
      ["ligatures"] = {
        [102] = {
          ["char"] = 11,
          ["type"] = 0
         },
        [108] = {
          ["char"] = 13,
          ["type"] = 0
         },
        [105] = {
          ["char"] = 12,
          ["type"] = 0
         }
       },
      ["width"] = 200250
     }
\stoptyping

The following top-level keys can be present inside a character hash:

\starttabulate[|l|c|c|c|l|p|]
\NC key               \NC from VF  \NC from TFM \NC used\NC value type \NC description \NC\FR
\NC width             \NC yes      \NC yes      \NC yes \NC number \NC character's width, in sp (default 0)\NC\NR
\NC height            \NC no       \NC yes      \NC yes \NC number \NC character's height, in sp (default 0)\NC\NR
\NC depth             \NC no       \NC yes      \NC yes \NC number \NC character's depth, in sp (default 0)\NC\NR
\NC italic            \NC no       \NC yes      \NC yes \NC number \NC character's italic correction, in sp (default zero)\NC\NR
\NC next              \NC no       \NC yes      \NC yes \NC number \NC the `next larger' character index \NC\NR
\NC extensible        \NC no       \NC yes      \NC yes \NC table  \NC the constituent bits of an extensible recipe\NC\NR
\NC kerns             \NC no       \NC yes      \NC yes \NC table  \NC kerning information\NC\NR
\NC ligatures         \NC no       \NC yes      \NC yes \NC table  \NC ligaturing information\NC\NR
\NC commands          \NC yes      \NC no       \NC yes \NC array  \NC virtual font commands\NC\NR
\NC name              \NC no       \NC no       \NC no  \NC string \NC the character (PostScript) name\NC\NR
\NC index             \NC no       \NC no       \NC yes \NC number \NC the (opentype or truetyoe) font glyph index\NC\NR
\NC used              \NC no       \NC yes      \NC yes \NC boolean\NC typeset already (default: false)?\NC\NR
\stoptabulate

The presence of \type{extensible} will overrule \type{next}, if that is also present.

The \type{extensible} table is very simple:
\starttabulate[|l|l|p|]
\NC key               \NC value type \NC description \NC\FR
\NC top               \NC number \NC `top' character index\NC\NR
\NC mid               \NC number \NC `middle' character index\NC\NR
\NC bot               \NC number \NC `bottom' character index\NC\NR
\NC rep               \NC number \NC `repeatable' character index\NC\NR
\stoptabulate

The \type{kerns} table is a hash indexed by character index (and
`character index' is defined as either a non-negative integer or the
string value `right_boundary'), with the values the kerning to be
appled, in scaled points.

The \type{ligatures} table is a hash indexed by character index (and
`character index' is defined as either a non-negative integer or the
string value `right_boundary'), with the values being yet another small 
hash, with two fields:
\starttabulate[|l|l|p|]
\NC key               \NC value type \NC description \NC\FR
\NC type              \NC number \NC the type of this ligature command, default 0\NC\NR
\NC char              \NC number \NC the character index of the resultant ligature\NC\NR
\stoptabulate
The \type{char} field in a ligature is required.

The \type{type} field inside a ligature is the numerical or string value of one of the eight
possible ligature types supported by \TeX.  When \TEX\ inserts a new ligature, it puts the new
glyph in the middle of the left and right glyphs. The original left and right glyphs can
optionally be retained, and when at least one of them is kept, it is also possible to move the
new `insertion point' forward one or two places. The glyph that ends up to the right of the
insertion point will become the next `left'.

\def\|{\string|}
\def\>{\string>}
\starttabulate[|l|l|l|p|]
\NC textual (Knuth)      \NC number  \NC string        \NC result (\| = final `insertion point')\NC\FR
\NC l + r =:     n       \NC 0       \NC \type{=:}     \NC \|n   \NC\NR
\NC l + r =:\|    n      \NC 1       \NC \type{=:|}    \NC \|nr  \NC\NR
\NC l + r \|=:    n      \NC 2       \NC \type{|=:}    \NC \|ln  \NC\NR
\NC l + r \|=:\|   n     \NC 3       \NC \type{|=:|}   \NC \|lnr \NC\NR
\NC l + r  =:\|\>  n     \NC 5       \NC \type{=:|>}   \NC n\|r  \NC\NR
\NC l + r \|=:\>   n     \NC 6       \NC \type{|=:>}   \NC l\|n  \NC\NR
\NC l + r \|=:\|\>  n    \NC 7       \NC \type{|=:|>}  \NC l\|nr \NC\NR
\NC l + r \|=:\|\>\> n   \NC 11      \NC \type{|=:|>>} \NC ln\|r \NC\NR
\stoptabulate

The default value is 0, and can be left out. That signifies a `normal'
ligature where the ligature replaces both original glyphs. 

The \type{commands} array is explained below.

\section {Real fonts}

Whether or not a \TEX\ font is a `real' font that should be written to
the PDF document is decided by the \type{type} value in the top-level
font structure. If the value is \type{real}, then this is a proper
font, and the inclusion mechanism will attempt to add the needed
font object definitions to the PDF.

Values for \type{type}:
\starttabulate[|l|p|]
\NC value          \NC description \NC\FR
\NC real          \NC This is a base font\NC\NR
\NC virtual       \NC This is a virtual font\NC\NR
\stoptabulate

The actions to be taken depend on a number of different variables:

\startitemize
\item Whether the used font fits in an 8-bit encoding scheme or not
\item The type of the disk font file
\item The level of embedding requested
\stopitemize

A font that uses anything other than an 8-bit encoding vector has to
be written to the PDF in a different way. 

The test that decides if this is the case is fairly simple in the 
current version of \LUATEX: If a `real' font has a `cidinfo' structure, 
then it is assumed to be a wide font, in all other cases it isn't. 
A more flexible approach is often possible, and will perhaps be 
implemented later.

If no special care is needed, \LUATEX\ currently falls back to the
mapfile||based solution used by \PDFTEX\ and DVIPS. This behaviour
will be removed in the future, when the existing code becomes
integrated in the new subsystem.

But if this is a `wide' font, then the new subsystem kicks in, and
some extra fields have to be present in the font structure. In this
case, \LUATEX\ does not use a map file at all.

The extra fields are: \type{format}, \type{embedding}, \type{fullname},
\type{cidinfo} (as explained above), \type{filename}, and the 
\type{index} key in the separate characters. 

Values for \type{format}:
\starttabulate[|l|p|]
\NC value          \NC description \NC\FR
\NC type1          \NC This is a PostScript Type1 font\NC\NR
\NC type3          \NC This is a bitmapped (PK) font\NC\NR
\NC truetype       \NC This is a TrueType or TrueType-based OpenType font\NC\NR
\NC opentype       \NC This is a PostScript-based OpenType font\NC\NR
\stoptabulate

Curerntly, only \type{truetype} and \type{opentype} fonts can be `wide' 
fonts (Type0 PostScript fonts are not supported).  

Values for \type{embedding}:
\starttabulate[|l|p|]
\NC value          \NC description \NC\FR
\NC no             \NC Don't embed the font at all\NC\NR
\NC subset         \NC Include and atttempt to subset the font\NC\NR
\NC full           \NC Include this font in it's entirety\NC\NR
\stoptabulate

At the moment, \type{full} is the only implemented form. 

It is not possible to artificially modify the transformation matrix
for the font at the moment.

The other fields are used as follows: The \type{fullname} will be the
PostScript/PDF font name. The \type{cidinfo} will be used as the
character set (the CID \type{/Ordering} and \type{/Registry} keys). The
\type{filename} points to the actual font file. If you include the 
full path in the \type{filename} or if the file is in the local
directory, \LUATEX\ will run a little bit more efficient because it
will not have to re-run the \type{find_xxx_file} callback in that
case.

Be careful: when mixing old and new fonts in one document, it is possible to
create name PostScript name clashes that can result in printing
errors. When this happens, you have to change the \type{fullname}
of the font.

Typeset strings are written out in a wide format using 2 bytes per
glyph, using the \type{index} key in the character information as
value. The overall effect is like having an encoding based on numbers
instead of traditional (PostScript) name-based reencoding.

This type of reencoding means that there is no longer a clear
connection between the text in your input file and the strings in the
output PDF file; I have not found a convenient away around that yet.


\section {Virtual fonts}

You have to take the following steps if you want \LUATEX\ to treat the
returned table from `define_font' as a virtual font:

\startitemize
\item Set the top-level key `type' to `virtual'.
\item Make sure there is at least one valid entry in `fonts' (see below)
\item Give a `commands' array to every character (see below)
\stopitemize


The presence of the toplevel `type' key with the specific value
'virtual' will trigger handling of the rest of the special virtual
font fields in the table, but the mere existance of 'type' is enough
to prevent luatex from looking for a virtual font on its own.

Therefore, this also works `in reverse': if you are absolutely certain
that a font is not a virtual font, assigning the value `base' or
`real' to `type' will inhibit \LUATEX\ from looking for a virtual font
file, thereby saving you a disk search.


The \type{fonts} is another Lua array. The values are one- or two-key
hashes themselves, each entry indicating one of the base fonts in a
virtual font. An example makes this easy to understand

\starttyping
    "fonts" = { { name = "ptmr8a", size = 655360}, 
                { name = "psyr", size = 600000},
                { id = 38 } }
\stoptyping

says that the first referenced font (index 1) in this virtual font is
\type{ptrmr8a} loaded at 10pt, and the second is \type{psyr}  loaded 
at a little over 9pt. The third one is previously defined font that 
is known to luatex as fontid `38'.

The array index numbers are used by the character command definitions
that are part of each character.


The \type{commands} array is a hash here each item is another small array, with first 
entry representing a command and the extra items the parameters to that command. The
allowed commands and their arguments are:
\starttabulate[|l|l|l|l|p|]
\NC command name      \NC arguments \NC arg type  \NC description \NC\FR
\NC font              \NC 1         \NC number    \NC select a new font from the local 'fonts' table\NC\NR
\NC char              \NC 1         \NC number    \NC typeset this character number from the current 
                                                      font, and move right\NC\NR
\NC slot              \NC 2         \NC number    \NC a shortcut for a font, char set\NC\NR
\NC push              \NC 0         \NC --        \NC save current position\NC\NR
\NC nop               \NC 0         \NC --        \NC do nothing \NC\NR
\NC pop               \NC 0         \NC --        \NC pop position \NC\NR
\NC rule              \NC 2         \NC 2 numbers \NC output a rule $w*h$, and move right\NC\NR
\NC down              \NC 1         \NC number    \NC move down on the page\NC\NR
\NC right             \NC 1         \NC number    \NC move right on the page\NC\NR
\NC special           \NC 1         \NC string    \NC output a \type{\special} command\NC\NR
\NC comment           \NC any       \NC any       \NC the rest of the command is ignored\NC\NR
\stoptabulate

Here is a rather elaborate example:
\starttyping  
     ...
     "commands" = {
        {"push"},                     -- remember where we are
        {"right", 5000},              -- move right about 0.08pt
        {"font", 1},                  -- select the fonts[1] entry
        {"char", 97},                 -- place character 97 'a'
        {"pop"},                      -- go all the way back
        {"down", -200000},            -- move *up* about 3pt
        {"special", "pdf: 1 0 0 rg"}  -- switch to red color
        {"rule", 500000, 20000}       -- draw a bar
        {'special',"pdf: 0 g"}        -- back to black
     }
     ...
\stoptyping

The default value for `font' is always 1, for each character anew. If
the virtual font is essentially only a re-encoding, then you do usually
do not have create an explicit `font' entry. 

Regardless of the amount of movement you create within the `commands',
the output pointer will always move by exactly the width as given in
the `width' key of the character hash, after running the `commands.

Even in a `real' font, there can be virtual characters: When \LUATEX\ encounters a `commands'
field inside a character when it becomes time to typeset the character, it will interpret the
commands, just like for a true virtual character. In this case, if you have created no `fonts'
array, then the default and only `base' font is taken to be the current font itself. In
practise, this means that you can create virtual duplicates of existing characters.

Note: this feature does {\it not\/} work the other way around. There can not be `real' 
characters in a virtual font!

Finally, here is a plain \TEX\ input file with a demonstration:

\starttyping
% start of virtual-demo.tex

\pdfoutput=1
\directlua0 {
   callback.register("define_font",
     function (name,area,size)
        if name == 'cmr10-red' then
            f = font.read_tfm('cmr10',size)
            f.name = 'cmr10-red'
            f.type = 'virtual'
            f.fonts = {{'cmr10', size}}
            for i,v in pairs(f.characters) do
                if (string.char(i)):find("[tacohanshartmut]") then
                    v.commands = {
                        {'special','pdf: 1 0 0 rg'},
                        {'char',i},
                        {'special','pdf: 0 g'},
                    }
                else
                    v.commands = {{'char',i}}
                end
            end
        else
          f = font.read_tfm(name,size)
        end
        return f
        end )
     }

\font\myfont = cmr10-red \myfont  This is a line of text \par
\font\myfontx= cmr10 \myfontx Here is another line of text \par

\bye
% end of virtual-demo.tex
\stoptyping

\chapter{Modifications}

Besides the expected changes caused by new functionality, there are a
number of not-so-expected changes. These are sometimes a side-effect
of a new (conflicting) feature, or, more often than not, a change
necessary to clean up the internal interfaces.


\section{Changes from \TEX\ 3.141592}

\startitemize

\item There is no pool file, all strings are embedded during compilation.

\item "plus 1 fillll" does not generate an error. The extra `l' is
simply typeset.

\stopitemize

\section{Changes from \ETEX\ 2.2}

\startitemize
\item The \ETEX\ functionality is always present and enabled
   (but see below about \TEXXET), so the prepended asterisk or
   \type{-etex} switch for initex is not needed. 

\item \TEXXET\ is not present, so the primitives
\starttyping
    \TeXXeTstate
    \beginR
    \beginL
    \endR
    \endL
\stoptyping
   are missing

\stopitemize

\section{Changes from \PDFTEX\ 1.40}

\startitemize
\item A number of `utility functions' is removed:
\starttyping
    \pdfelapsedtime
    \pdfescapehex
    \pdfescapename
    \pdfescapestring
    \pdffiledump
    \pdffilemoddate
    \pdffilesize
    \pdflastmatch
    \pdfmatch
    \pdfmdfivesum
    \pdfresettimer
    \pdfshellescape
    \pdfstrcmp
    \pdfunescapehex
\stoptyping

\item A few other experimental primitives are provided without the
      extra  `pdf' prefix, so they are simply called:
\starttyping
    \primitive
    \ifprimitive
    \ifabsnum
    \ifabsdim
\stoptyping

\stopitemize

\section{Changes from \ALEPH\ RC4}

\startitemize
\item The input translations from \ALEPH\ are not implemented, the
   related primitives are not available

\starttyping
    \DefaultInputMode
    \noDefaultInputMode
    \noInputMode
    \InputMode
    \DefaultOutputMode
    \noDefaultOutputMode
    \noOutputMode
    \OutputMode
    \DefaultInputTranslation
    \noDefaultInputTranslation
    \noInputTranslation
    \InputTranslation
    \DefaultOutputTranslation
    \noDefaultOutputTranslation
    \noOutputTranslation
    \OutputTranslation
\stoptyping

\item A small series of bounds checking fixes to \type{\ocp} and 
   \type{\ocplist} has been added to prevent the system from crashing
   due to array indexes running out of bounds.

\item The \type{\hoffset} bug when \type{\pagedir TRT}  is fixed,
removing the need for an explicit fix to \type{\hoffset}

\item A bug causing \type{\fam} to fail for family numbers above
    15 is fixed.

\item Some bits of \ALEPH\ assumed \type{0} and \type{null} were identical.
This resulted for instance in a bug that sometimes caused an eternal
loop when trying to \type{\show} a box.

\item A fair amount of minor bugs are fixed as well, most of these
related to \type{\tracingcommands} output.

\item The number of possible fonts, ocps and ocplists is 
smaller than their maximum \ALEPH\ value (around 5000 fonts and 
30000 ocps / ocplists).

\item The internal function \type{scan_dir()} has been renamed to
\type{scan_direction()} to prevent a naming clash.

\stopitemize

\section{Changes from standard \WEBC}

\startitemize

\item There is no mltex 

\item There is no enctex

\item The following command-line switches are silently ignored, even
in non||lua mode:
\starttyping
  -8bit
  -translate-file=TCXNAME
  -mltex
  -enc
  -etex
\stoptyping

\item \type{\openout} whatsits are not written to the log file.

\item Some of the so||called web2c extensions are hard to set up 
  in non-kpse mode because texmf.cnf is not read: \type{shell-escape}
  is off (but that is not a problem because of Lua's
  \type{os.execute}), and the paranoia checks on \type{openin} and
  \type{openout} do not happen (however, it is easy for a Lua script
  to do this itself by overloading \type{io.open}).

\stopitemize

\chapter{Implementation notes}

\subsection{Primitives overlap}

The primitives
\starttyping
      \pdfpagewidth and \pagewidth,
      \pdfpageheight and \pageheight,
      \fontcharwd and \charwd,
      \fontcharht and \charht,
      \fontchardp and \chardp,
      \fontcharic and \charic,
\stoptyping
are all aliases of each other.

\subsection{Sparse arrays}

The \type{\mathcode}, \type{\delcode}, \type{\catcode},
\type{\sfcode}, \type{\lccode} and \type{\uccode} tables are now
sparse arrays that are implemented in C. They are no longer part of
the \TEX\ ``equivalence table'' and because each had 1.1 million
entries with a few memory words each, this makes a major difference
in memory usage.

These assignments do not yet show up when using the etex tracing
routines \type{\tracingassigns} and \type{\tracingrestores} (code
simply not written yet)

A side-effect of the current implementation is that \type{\global} is
now more expensive in terms of processing than non-global assignments.

See \type{mathcodes.c} and \type{textcodes.c} if you are interested in
the gory details.

Also, the glyph ids within a font are now managed by means
of a sparse array and glyph ids can go up to index $2^21-1$. 

\subsection{Simple single-character csnames}

Single-character commands are no longer treated aspecially in the
internals, they are stored in the hash just like the multiletter
csnames. 

The code that displays control sequences explicitly checks if
the length is one when it has to decide whether or not to add a
trailing space.

\subsection{Compressed format}

The format is passed through zlib, allowing it to shrink to roughly a
third of the size it would have had in uncompressed form. This takes a
bit more CPU cycles but much less disk I/O, so it should still be
faster. 

The chosen compression factor is fairly low, equivalent to \type{gzip -3}.

\subsection{Binary file reading}

All of the internal code is changed in such a way that if one of the
\type{read_xxx_file} callbacks is not set, then the file is read by
a C function using basically the same convention as the callback: a
single read into a buffer big enough to hold the entire file
contents. While this uses more memory than the previous code (that
mostly used \type{getc} calls), it can be quite a bit faster
(depending on your I/O subsystem).


\chapter{Known bugs}

The bugs below are going to be fixed eventually. 

The top ones will be fixed soon, but in the later items either the
actual problem is hard to find, or the code that causes the bug is
going to be replaced by a new subsystem soon anyway.

\startitemize

\item Not all of Aleph's direction commands are handled properly in 
PDF mode yet: this affects all the Top-Bottom and Bottom-Top writing 
directions.

\item Letter spacing (\type{\letterspacefont}) is currently non-functional 
due to massive changes in the virtual font handling. This
functionality may actually be removed completely in the future,
because it is straightforward to set up letterspacing using the Lua
'define_font' interface.

\item Attempting hyphenation in initex (sometimes) creates segfaults.

\item Hyphenation can only deal with the Base Multilingual Plane (BMP)

\item \type{tex.print()} and \type{tex.sprint()} do not work if 
\type{\directlua} is used in an OTP file (in the output of an 
\type{expression} rule).

\stopitemize

\chapter{TODO}

On top of the `normal' extensions that are planned, there are some
more specific small feature requests .

\startitemize

\item Implement the \TEX\ primitive \type{\dimension}, cf. \type{\number}

\item Change the lua table type{tex.dimen} to accept and return float
values instead of strings

\item Do something about \type{\withoutpt} and/or a new register type \type{\real}?

\item Implement the \TEX\ primitive \type{\htdp}?

\item Do boxes with dual baselines.

\item A way to (re?)calculate the width of a  \type{\vbox}, taking only
the natural width of the included items into account.

\item Make the number of the output box configurable.

\stopitemize


\stoptext


